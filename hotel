Lib/auxiliaries.rkt: (contract-out
Lib/auxiliaries.rkt:  (randomly-pick (-> cons? any))
Lib/auxiliaries.rkt:   (-> list? boolean?))
Lib/auxiliaries.rkt:   (->i ((cmp (-> any/c any/c any))) (#:key (key (-> any/c any))) (ok? (-> list? any))))
Lib/auxiliaries.rkt:   (->i ([l (key) (and/c cons? (sorted >= #:key (if (unsupplied-arg? key) values key)))])
Lib/auxiliaries.rkt:        ([key (-> any/c real?)]
Lib/auxiliaries.rkt:         #:info [info (-> any/c any/c)])
Lib/auxiliaries.rkt:        (list-of-winners cons?)))
Lib/auxiliaries.rkt:   ;; create equal-valued partitions (sorted), assuming the list is sorted 
Lib/auxiliaries.rkt:   (->i ([l (key) (and/c cons? 
Lib/auxiliaries.rkt:                          (sorted <= #:key (if (unsupplied-arg? key) values key))
Lib/auxiliaries.rkt:                          (sorted >= #:key (if (unsupplied-arg? key) values key))))])
Lib/auxiliaries.rkt:        ([key (-> any/c real?)] 
Lib/auxiliaries.rkt:         #:info (info (-> any/c any/c)))
Lib/auxiliaries.rkt:  (combinations/no-order
Lib/auxiliaries.rkt:   (->i ([k natural-number/c][l (k) (and/c list? (compose (>=/c k) length))])
Lib/auxiliaries.rkt:        [result (k l) (and/c [listof list?] (compose (=/c (co-no-order# (length l) k)) length))]))))
Lib/auxiliaries.rkt:;; (co-no-order# (-> natural-number/c natural-number/c natural-number/c))
Lib/auxiliaries.rkt:(define (co-no-order# n k)
Lib/auxiliaries.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/auxiliaries.rkt:(define (randomly-pick l)
Lib/auxiliaries.rkt:  (list-ref l (random (length l))))
Lib/auxiliaries.rkt:(define (partition lo-h-size (selector values) #:info (info values))
Lib/auxiliaries.rkt:  (define one (first lo-h-size))
Lib/auxiliaries.rkt:  (let loop [(pred (selector one)) (l (rest lo-h-size)) [partition (list (info one))]]
Lib/auxiliaries.rkt:(define (winners lo-h-size (selector values) #:info (info values))
Lib/auxiliaries.rkt:  (first (partition lo-h-size selector #:info info)))
Lib/auxiliaries.rkt:(define (combinations/no-order n lox)
Lib/auxiliaries.rkt:     (define chs (combinations/no-order (- n 1) (rest lox)))
Lib/auxiliaries.rkt:     (append (map (lambda (n-1) (cons one n-1)) chs) (combinations/no-order n (rest lox)))]))
Lib/auxiliaries.rkt:  ; (check-equal? (choice 3 '()) '(()))
Lib/auxiliaries.rkt:  (check-equal? (combinations/no-order 1 '(a b c)) '((a) (b) (c) ()))
Lib/auxiliaries.rkt:  (check-equal? (combinations/no-order 2 '(a b c)) '((a b) (a c) (a) (b c) (b) (c) ()))
Lib/auxiliaries.rkt:  (check-equal? (combinations/no-order 3 '(a b c)) '((a b c) (a b) (a c) (a) (b c) (b) (c) ()))
Lib/auxiliaries.rkt:  (define l (build-list 100 add1))
Lib/auxiliaries.rkt:  (define x (randomly-pick l))
Lib/auxiliaries.rkt:  (check-true (cons? (member x l)))
Lib/auxiliaries.rkt:  (check-false ((sorted <= #:key second) '((a 6) (b 4) (c 4))))
Lib/auxiliaries.rkt:  (check-true ((sorted >= #:key second) '((a 6) (b 4) (c 4))))
Lib/auxiliaries.rkt:  (check-true (distinct (build-list 10 (位 (i) (list i i)))))
Lib/auxiliaries.rkt:  (check-true (distinct (build-list 10 number->string)))
Lib/auxiliaries.rkt:  (check-false (distinct (build-list 10 (位 (_) 1))))
Lib/auxiliaries.rkt:  (check-equal? (winners '(3 3 2 1)) '(3 3))
Lib/auxiliaries.rkt:  (check-equal? (winners '((a 3) (b 3) (c 2) (d 1)) second) '((a 3) (b 3)))
Lib/auxiliaries.rkt:  (check-equal? (winners '((a 3) (b 3) (c 2) (d 1)) second #:info first) '(a b))
Lib/auxiliaries.rkt:  (check-equal? (partition '(1 1 2)) '((1 1) (2)))
Lib/auxiliaries.rkt:  (check-equal? (partition '(1 1 2 2 3)) '((1 1) (2 2) (3))))
Lib/contract.rkt: ;; (interface name f-optional-with-ctc ...)
Lib/contract.rkt: ;; 'name' gives a name to the interface that provides via contract-out all f's with contract 
Lib/contract.rkt: ;; an interface is typically specified in a separate file say "server-intf.rkt"
Lib/contract.rkt: ;; connects the specification to actual definitions (should be done on a 'by-name' basis)
Lib/contract.rkt: ;; (testing def-or-exp ...)
Lib/contract.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/contract.rkt:(require unstable/contract (for-syntax "../Performance/with-contract.rkt"))
Lib/contract.rkt:(define-syntax (interface stx)
Lib/contract.rkt:  (syntax-case stx (subject-to)
Lib/contract.rkt:     (let* ([clauses (syntax->list #'(clauses ...))]
Lib/contract.rkt:            [ids-with-contracts
Lib/contract.rkt:                      (syntax-case stx ()
Lib/contract.rkt:            [ids-that-came-with-contracts 
Lib/contract.rkt:             (map car ids-with-contracts)]
Lib/contract.rkt:            [contracts-for-ids-with-contracts
Lib/contract.rkt:             (map cadr ids-with-contracts)]
Lib/contract.rkt:            [ids-without-contracts
Lib/contract.rkt:                      (syntax-case stx ()
Lib/contract.rkt:            [all-ids
Lib/contract.rkt:                      (syntax-case stx ()
Lib/contract.rkt:       (with-syntax ([(ids-that-came-with-contracts ...) ids-that-came-with-contracts]
Lib/contract.rkt:                     [(their-contracts ...) contracts-for-ids-with-contracts]
Lib/contract.rkt:                     [(fresh-names ...) (generate-temporaries ids-that-came-with-contracts)]
Lib/contract.rkt:                     [(ids-without-contracts ...) ids-without-contracts]
Lib/contract.rkt:                     [(all-ids ...) all-ids])
Lib/contract.rkt:             ; (define (ids-that-came-with-contracts . x) 0) ...
Lib/contract.rkt:             ; (define ids-without-contracts 0) ...
Lib/contract.rkt:               (define (ids-that-came-with-contracts) 0) ...
Lib/contract.rkt:               (define fresh-names their-contracts) ...
Lib/contract.rkt:             (define-syntax (name stx)
Lib/contract.rkt:               (syntax-case stx ()
Lib/contract.rkt:                 [(name all-ids ...) 
Lib/contract.rkt:                  #`(provide ids-without-contracts ...
Lib/contract.rkt:                             ids-that-came-with-contracts ...)])))))]))
Lib/contract.rkt:; (interface tst& (foo (-> integer? integer?)))
Lib/contract.rkt:(define-syntax-rule (==> a b) (if a b #t))
Lib/contract.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/contract.rkt:(define-syntax-rule
Lib/contract.rkt:  (testing def-or-exp ...)
Lib/contract.rkt:    (check-equal? 1 1)
Lib/contract.rkt:    def-or-exp ...))
Lib/io.rkt: ;; Symbol X -> X 
Lib/io.rkt: ;; tee with pretty-print 
Lib/io.rkt: ;; [InputPort] -> Xexpr | EOF 
Lib/io.rkt: read-xml-from
Lib/io.rkt: ;; Xexpr [OutputPort] -> Void
Lib/io.rkt: write-xml-to
Lib/io.rkt: ;; depends on parameter create-tests
Lib/io.rkt: ;; #f -> do not create files 
Lib/io.rkt: ;; #t -> do create files 
Lib/io.rkt: create-tests)
Lib/io.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/io.rkt:(define read-xml-from
Lib/io.rkt:  (case-lambda 
Lib/io.rkt:    [() (read-xml-from (current-input-port))]
Lib/io.rkt:     (with-handlers ((exn:xml? (位 (x) eof)))
Lib/io.rkt:       (xml->xexpr ((eliminate-whitespace '() (位 (x) #t)) (read-xml/element ip))))]))
Lib/io.rkt:(define write-xml-to
Lib/io.rkt:  (case-lambda
Lib/io.rkt:     (display-xml/content (xexpr->xml x) op)
Lib/io.rkt:     ; (write-xexpr x op)
Lib/io.rkt:     (flush-output op)]
Lib/io.rkt:     (write-xml-to x (current-output-port))]))
Lib/io.rkt:(define-syntax-rule 
Lib/io.rkt:  (if (create-tests)
Lib/io.rkt:(define create-tests (make-parameter #f))
Lib/io.rkt:;; String Xexpr -> Void
Lib/io.rkt:  (with-output-to-file target
Lib/io.rkt:      (write-xml-to x)))
Lib/io.rkt:  (pretty-print `(,t ,x))
Lib/log.rkt: #;(contract-out 
Lib/log.rkt:  (log (-> (list/c any/c any/c) any/c any))))
Lib/log.rkt:;; [List X (U String Exn S-expr)] String -> Void 
Lib/log.rkt:  (define (racket-loging)
Lib/log.rkt:    (log-info msg)
Lib/log.rkt:      [(string? xn) (log-info xn)]
Lib/log.rkt:      [(exn? xn) (with-output-to-string (lambda () ((error-display-handler) (exn-message xn) xn)))]
Lib/log.rkt:      [else (with-output-to-string (lambda () (pretty-print xn)))]))
Lib/log.rkt:  (define (my-logging)
Lib/log.rkt:      [(exn? xn) ((error-display-handler) (exn-message xn) xn)]
Lib/log.rkt:      [else (pretty-print xn)]))
Lib/log.rkt:  (racket-logging)
Lib/log.rkt:  (my-logging))
Lib/sandbox.rkt: ;; [->* Any] [Any *-> Any] [S-expr -> Any] #:time T #:memory M -> Any 
Lib/sandbox.rkt: ;; -- accessing or deleting files 
Lib/sandbox.rkt: ;; -- displaying a gui 
Lib/sandbox.rkt: ;; -- reading or writing 
Lib/sandbox.rkt: ;; -- network connections 
Lib/sandbox.rkt: in-sandbox)
Lib/sandbox.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/sandbox.rkt:  (check-equal? (in-sandbox (lambda () (values 1 2 3)) succ fail) 6)
Lib/sandbox.rkt:  (check-equal? (in-sandbox (lambda () (sleep 2 #;"secs")) succ fail) 'failure)
Lib/sandbox.rkt:  (check-equal? (in-sandbox (lambda () (void (make-bytes 100000000))) succ fail) 'failure)
Lib/sandbox.rkt:  (check-equal? (in-sandbox (lambda () (error 'x "y")) succ fail) 'failure))
Lib/sandbox.rkt:(define (in-sandbox producer consumer failure #:time (sec-limit 1) #:memory (mb-limit 30))
Lib/sandbox.rkt:     (define-syntax-rule (jump x) (fail (lambda () (failure x))))
Lib/sandbox.rkt:     (call-with-values
Lib/sandbox.rkt:        (with-handlers
Lib/sandbox.rkt:            ((exn:fail:resource? (lambda (x) (jump `(R ,(exn-message x)))))
Lib/sandbox.rkt:             (exn:fail:out-of-memory? (lambda (x) (jump `(R ,(exn-message x)))))
Lib/sandbox.rkt:             (exn:fail? (lambda (x) (jump `(X ,(exn-message x))))))
Lib/sandbox.rkt:          (with-limits sec-limit #;"s" mb-limit #;"Mb" (producer))))
Lib/struct.rkt: ;; (struct-open str s field ...)
Lib/struct.rkt: ;; (define-values (field ...) (values (str-field s) ...)
Lib/struct.rkt: struct-open)
Lib/struct.rkt:(require (for-syntax racket/syntax racket/struct-info))
Lib/struct.rkt:(define-syntax (struct-open stx)
Lib/struct.rkt:  (syntax-case stx ()
Lib/struct.rkt:    [(struct-open str s x ...)
Lib/struct.rkt:     ;; syntax-parse 
Lib/struct.rkt:     ;; -- str: id
Lib/struct.rkt:     ;; -- s : expression that evaluates to instance of str
Lib/struct.rkt:     ;; -- x ... : id and distinct plus at least one 
Lib/struct.rkt:     ;; ---------------------------------------------------
Lib/struct.rkt:     ;; -- parents and parent fields 
Lib/struct.rkt:     ;; -- we may wish to allow renaming (field taget-id)
Lib/struct.rkt:     (let ((x... (syntax->list #'(x ...))))
Lib/struct.rkt:       (define str-x...
Lib/struct.rkt:           (format-id #'str "~a-~a" #'str (syntax-e x))))
Lib/struct.rkt:       (define-values (str:id _constructor predicate accessors* _mutators* _super-type)
Lib/struct.rkt:         (apply values (extract-struct-info (syntax-local-value #'str))))
Lib/struct.rkt:       (for/and ((str-x str-x...))
Lib/struct.rkt:         (or (memf (lambda (x) (free-identifier=? str-x x)) accessors*)
Lib/struct.rkt:             (raise-syntax-error #f (format "~a not a field of ~a" (syntax-e str-x) str:id))))
Lib/struct.rkt:       (with-syntax ((str? predicate)
Lib/struct.rkt:                     ((str-x ...) str-x...))
Lib/struct.rkt:         #'(define-values (x ...) 
Lib/struct.rkt:                 (values (str-x s) ...)
Lib/struct.rkt:                 (error 'struct-open "~a not an instance of ~a" s str)))))]))
Lib/struct.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/struct.rkt:    (struct-open foo f bar)
Lib/struct.rkt:  (check-equal? (one f) (foo-bar f))
Lib/struct.rkt:    (struct-open foo f bar moo)
Lib/struct.rkt:  (check-equal? (two f) (cons (foo-bar f) (foo-moo f)))
Lib/struct.rkt:  (check-exn exn:fail? (lambda () (struct-open foo (cons 1 2)) 1))
Lib/struct.rkt:  (struct-copy foo f (bar 10))
Lib/struct.rkt:  ;; (struct-open foo f ggg)
Lib/xml.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/xml.rkt:(require (only-in xml xexpr?))
Lib/xml.rkt: (contract-out
Lib/xml.rkt:  (xml-element-diff
Lib/xml.rkt:   (-> xexpr? xexpr? boolean?))
Lib/xml.rkt:  (numbered-attributes
Lib/xml.rkt:   (-> string? (-> any/c xexpr?) (listof any/c) (listof (list/c symbol? string?)))))
Lib/xml.rkt: ;; --------------------------------------------------------------------------------------------------
Lib/xml.rkt: ;; parameter: Boolean -> Void U -> Boolean 
Lib/xml.rkt: ;;   Xexpr -> Boolean 
Lib/xml.rkt: ;;   -- a predicate
Lib/xml.rkt: ;;   -- ... to indicate a repetition of the preceding predicate 
Lib/xml.rkt: xml-predicate 
Lib/xml.rkt: ;;  (xml-parser (tag ((attribute class?) ...) nested ... #:action body:expr) ... optional-else)
Lib/xml.rkt: ;;   Xexpr -> X
Lib/xml.rkt: ;;   -- a named predicate (id pred?)
Lib/xml.rkt: ;;   -- ... to indicate a repetition of the preceding predicate 
Lib/xml.rkt: ;; optional-else is
Lib/xml.rkt: xml-parser)
Lib/xml.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/xml.rkt:(define verbose (make-parameter #f))
Lib/xml.rkt:;; Xexpr Xexpr -> Boolean 
Lib/xml.rkt:(define (xml-element-diff x y)
Lib/xml.rkt:  (define x-tag (first x))
Lib/xml.rkt:  (define y-tag (first y))
Lib/xml.rkt:    [(eq? x-tag y-tag) (xml-attribute-diff x-tag (rest x) (rest y))]
Lib/xml.rkt:          (printf "  1: ~e\n" x-tag)
Lib/xml.rkt:          (printf "  2: ~e\n" y-tag)
Lib/xml.rkt:;; SyXattr Xattr -> Boolean 
Lib/xml.rkt:(define (xml-attribute-diff tag attr+body1 attr+body2)
Lib/xml.rkt:     (define-values (x-attr x-err) (normalize-attribute tag (first attr+body1)))
Lib/xml.rkt:     (define-values (y-attr y-err) (normalize-attribute tag (first attr+body2)))
Lib/xml.rkt:       [(equal? x-attr y-attr) 
Lib/xml.rkt:        (when (and x-err (verbose))
Lib/xml.rkt:          (printf "  1: ~a\n" x-err)
Lib/xml.rkt:          (printf "  2: ~a\n" y-err))
Lib/xml.rkt:           (andmap xml-element-diff body1 body2)]
Lib/xml.rkt:             (printf "  1: ~e\n" x-attr)
Lib/xml.rkt:             (printf "  2: ~e\n" y-attr)
Lib/xml.rkt:;; Symbol [Listof [List Symbol String]] ->* [Listof [List Symbol (U String Number)]] (U String false)
Lib/xml.rkt:(define (normalize-attribute tag a)
Lib/xml.rkt:              [else (define num (string->number val))
Lib/xml.rkt:          ;; relying on left-to-right order here:
Lib/xml.rkt:;; Symbol Symbol -> Boolean 
Lib/xml.rkt:  (string<=? (symbol->string s) (symbol->string t)))
Lib/xml.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/xml.rkt:  (check-true (xml-element-diff '(p) '(p)))
Lib/xml.rkt:  (check-true (xml-element-diff '(p ((a1 "hello"))) '(p ((a1 "hello")))))
Lib/xml.rkt:  (check-true (xml-element-diff '(p ((a2 "world") (a1 "hello"))) '(p ((a1 "hello") (a2 "world")))))
Lib/xml.rkt:  (check-true
Lib/xml.rkt:   (xml-element-diff
Lib/xml.rkt:  (check-true
Lib/xml.rkt:   (xml-element-diff
Lib/xml.rkt:  (check-true
Lib/xml.rkt:   (xml-element-diff
Lib/xml.rkt:  (check-true (xml-element-diff '(error [[msg "a"]]) '(error [[msg "b"]])))
Lib/xml.rkt:  (check-false
Lib/xml.rkt:   (xml-element-diff
Lib/xml.rkt:  (check-false
Lib/xml.rkt:   (xml-element-diff
Lib/xml.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/xml.rkt:(define-syntax (xml-predicate stx)
Lib/xml.rkt:  (syntax-case stx ()
Lib/xml.rkt:     (with-syntax ([((nested ...) ...)
Lib/xml.rkt:                                  (syntax-case stx (...)
Lib/xml.rkt:                                (syntax->list stx)))
Lib/xml.rkt:                         (syntax->list #'((nested? ...) ...)))])
Lib/xml.rkt:             [(list 'tag (list-no-order `(attribute ,(? attribute? attribute)) ...)
Lib/xml.rkt:(define-syntax (xml-parser stx)
Lib/xml.rkt:  (syntax-case stx (else)
Lib/xml.rkt:    [(_ (tag ((attribute check-attribute) ...) nested? ... #:action action) ... [else e])
Lib/xml.rkt:                           (syntax-case stx (...)
Lib/xml.rkt:                         (syntax->list stx)))
Lib/xml.rkt:                  (syntax->list #'((nested? ...) ...)))]
Lib/xml.rkt:            [bind-single
Lib/xml.rkt:               (syntax-case stx ()
Lib/xml.rkt:            [bind-map
Lib/xml.rkt:               (syntax-case stx ()
Lib/xml.rkt:            [parsed-ns 
Lib/xml.rkt:                   [(null? (cdr ns)) (cons (bind-single (car ns)) (loop (cdr ns)))]
Lib/xml.rkt:                        (cons (bind-map (car ns)) (loop (cddr ns)))
Lib/xml.rkt:                        (cons (bind-single (car ns)) (loop (cdr ns))))])))])
Lib/xml.rkt:       (with-syntax ([((n ...) ...) ns]
Lib/xml.rkt:                     [((n-parsed ...) ...) parsed-ns])
Lib/xml.rkt:               [(list 'tag (list-no-order `(attribute ,(? check-attribute attribute)) ...) n ...)
Lib/xml.rkt:                (let ((attribute (check-attribute attribute))
Lib/xml.rkt:                  (let (n-parsed ...)
Lib/xml.rkt:    [(_ (tag ((attribute check-attribute) ...) nested? ... #:action action) ...)
Lib/xml.rkt:     #'(xml-parser (tag ((attribute check-attribute) ...) nested? ... #:action action) ... [else #f])]))
Lib/xml.rkt:  (define board? (xml-predicate (board () tile? ... hotel? ...)))
Lib/xml.rkt:  (define hotel? (xml-predicate (hotel ((name label?)) tile? ...)))
Lib/xml.rkt:  (define tile?  (xml-predicate (tile ((column column?) (row row?)))))
Lib/xml.rkt:  ;; -------------------------------------------------------------------------------------------------
Lib/xml.rkt:  (check-true (tile? (tile "1" "a")))
Lib/xml.rkt:  (check-true (hotel? (hotel "American" (tile "1" "a") (tile "2" "a"))))
Lib/xml.rkt:  (check-true (label? "hello"))
Lib/xml.rkt:  (check-true (board? `(board ())))
Lib/xml.rkt:  (check-true
Lib/xml.rkt:  (check-true
Lib/xml.rkt:  (check-true
Lib/xml.rkt:  ;; -------------------------------------------------------------------------------------------------
Lib/xml.rkt:  (define board-p
Lib/xml.rkt:    (xml-parser
Lib/xml.rkt:     (board () (t tile-p) ... (h hotel-p) ... #:action (list 'board t h))))
Lib/xml.rkt:  (define hotel-p 
Lib/xml.rkt:    (xml-parser
Lib/xml.rkt:     (hotel ((name label-p)) (t tile-p) ... #:action (list 'hotel name t))))
Lib/xml.rkt:  (define tile-p 
Lib/xml.rkt:    (xml-parser
Lib/xml.rkt:     (tile ((column column-p) (row row-p)) #:action (list 'tile row column))))
Lib/xml.rkt:  (define label-p string->number)
Lib/xml.rkt:  (define column-p values)
Lib/xml.rkt:  (define row-p string->number)
Lib/xml.rkt:  ;; -------------------------------------------------------------------------------------------------
Lib/xml.rkt:  (check-equal? (tile-p (tile "1" "a")) '(tile 1 "a"))
Lib/xml.rkt:  (check-equal? (hotel-p (hotel "55" (tile "1" "a") (tile "2" "a")))
Lib/xml.rkt:  (check-equal? (label-p "1") 1)
Lib/xml.rkt:  (check-equal? (board-p `(board ())) '(board () ()))
Lib/xml.rkt:  (check-equal? (board-p `(board () ,(tile "1" "A") ,(tile "1" "A")))
Lib/xml.rkt:  (check-equal? (board-p`(board () ,(hotel "42" (tile "1" "B"))))
Lib/xml.rkt:  (check-equal? (board-p `(board () ,(tile "1" "A") ,(tile "1" "A") ,(hotel "32" (tile "1" "B"))))
Lib/xml.rkt:;; ---------------------------------------------------------------------------------------------------
Lib/xml.rkt:(define (numbered-attributes format-string x->xexpr attribute-values)
Lib/xml.rkt:  (for/list ((h attribute-values) (i (in-naturals))) 
Lib/xml.rkt:    `(,(format-symbol format-string (+ i 1)) ,(x->xexpr h))))
Lib/xml.rkt:  (check-equal? (numbered-attributes "foo~a" number->string '(1 2)) '((foo1 "1") (foo2 "2"))))
Performance/with-contract.rkt:(provide with-contracts)
Performance/with-contract.rkt:(define with-contracts #t)
README.txt:client-start: launch a named remote client for an Acquire game 
README.txt:sever-start:  launch a server for an Acquire game 
README.txt:remote-game: run tests for the remote version of the game 
README.txt:tree-game:   run tests for the local version of the game 
README.txt:   player-intf |  protocol |  strategy-intf
README.txt:      +-------------------------+
README.txt:               player-factory
README.txt:                  tree-game || tree-game-intf <==== entry point to play
README.txt:   --- remote-proxy layer exists here ---
README.txt:   --- remote-actor[intf], remote-admin, remote-player ---
README.txt:                            || game-intf      <==== entry point to play
README.txt:      +------------------+------------------+--------------...
README.txt:   state-intf       board-intf         basics-intf     tree-intf
README.txt:     auxiliaries -- basic library functions 
README.txt:     contract    -- contracts, should be in unstable/contract 
README.txt:     io          -- some I/O functions 
README.txt:     log         -- central place for logging exns 
README.txt:     sandbox     -- wire up 'with-limit' in a function 
README.txt:     struct      -- a facility for opening up structs locally 
README.txt:     xml         -- XML parsing utilities 
README.txt:     with-contract -- a file that governs whether contracts should be checked
README.txt: * protocols occasionally seems to use state-place-tile on player that 
README.txt:   doesn't have the tile (merger perhaps? -- not reproducible)
admin-intf.rkt:;; ---------------------------------------------------------------------------------------------------
admin-intf.rkt:(require "basics.rkt" "board.rkt" "protocols.rkt" "state-intf.rkt" "state.rkt" "strategy-intf.rkt" 
admin-intf.rkt:   turn-player/c)
admin-intf.rkt:;; ---------------------------------------------------------------------------------------------------
admin-intf.rkt:   (init-field (next-tile (-> (listof tile?) tile?)))
admin-intf.rkt:   (sign-up (->m string? (instanceof/c (recursive-contract player/c)) string?))
admin-intf.rkt:   (show-players (->m (listof string?)))
admin-intf.rkt:    (->dm ((turns# natural-number/c)) (#:show (show (-> natural-number/c state? any)))
admin-intf.rkt:   (init-field (name string?))
admin-intf.rkt:   (init-field (choice strategy/c)) 
admin-intf.rkt:    (->m (instanceof/c administrator/c) any))
admin-intf.rkt:    (->m state? any))
admin-intf.rkt:   (take-turn
admin-intf.rkt:    (->dm ([turn (instanceof/c turn-player/c)])
admin-intf.rkt:           (tile (and/c (maybe/c tile?) (good-placement turn)))
admin-intf.rkt:           (hotel (and/c (maybe/c hotel?) (good-hotel-for-placement turn tile)))
admin-intf.rkt:           (to-buy (and/c shares-order/c (good-shares turn tile hotel))))))
admin-intf.rkt:    (->dm ([acquired-hotels (listof hotel?)]) 
admin-intf.rkt:          (decisions (and/c (listof boolean?) (compose (=/c (length acquired-hotels)) length)))))
admin-intf.rkt:   (receive-tile
admin-intf.rkt:    (->m tile? any))
admin-intf.rkt:    (->m state? any))
admin-intf.rkt:   (the-end
admin-intf.rkt:    (->m state? score/c any))))
admin.rkt:;; ---------------------------------------------------------------------------------------------------
admin.rkt:(require "admin-intf.rkt") 
admin.rkt:;; ---------------------------------------------------------------------------------------------------
admin.rkt:(require "typed-wrapper.rkt" "tree.rkt")
admin.rkt:    (require rackunit (submod "state.rkt" sample-states) (submod "board.rkt" tiles+spots)))
admin.rkt:(define-type Player%
admin.rkt:   (init-field [name String]
admin.rkt:   [go ((Instance Administrator%) -> Any)]
admin.rkt:   [setup (State -> Any)]
admin.rkt:   [take-turn ((Instance Turn-Player%) -> (Values (Option Tile)
admin.rkt:                                                  Shares-Order))]
admin.rkt:   [keep ((Listof Hotel) -> (Listof Boolean))]
admin.rkt:   [receive-tile (Tile -> Any)]
admin.rkt:   [inform [State -> Any]]
admin.rkt:   [the-end (State Score -> Any)]))
admin.rkt:(define-type Administrator%
admin.rkt:   (init-field [next-tile ((Listof Tile) -> Tile)])
admin.rkt:   [sign-up (String (Instance Player%) -> String)]
admin.rkt:   [show-players (-> (Listof String))]
admin.rkt:   [run (Natural [#:show (Natural State -> Any)] -> (Values Symbol Any (Listof State)))]))
admin.rkt:    (init-field next-tile)
admin.rkt:    (super-new)
admin.rkt:    (: *named-players (Listof (List String (Instance Player%))))
admin.rkt:    (define *named-players '())
admin.rkt:    (define/public (sign-up name player)
admin.rkt:      (set! name (format "~a~a:~a" pre (number->string *count) name))
admin.rkt:      (set! *named-players (cons (list name player) *named-players))
admin.rkt:    (define/public (show-players)
admin.rkt:      ((inst map String (List String (Instance Player%))) first *named-players))
admin.rkt:      (define players (player->internals))
admin.rkt:      (define tree0 (generate-tree (setup-all players (apply state0 players))))
admin.rkt:      (let: loop : (Values Symbol Any (Listof State)) ([tree tree0][n : Natural turns#][states (list (tree-state tree0))])
admin.rkt:        (define state (tree-state tree))
admin.rkt:           (values DONE (state-score state) (reverse states))]
admin.rkt:          [(empty? (state-players state))
admin.rkt:           (values EXHAUSTED (state-score state) (reverse states))]
admin.rkt:          [(not (decision-tree? tree))
admin.rkt:           (values SCORE (state-score state) (reverse states))]
admin.rkt:           (define external (cast (player-external (state-current-player state)) (Instance Player%)))
admin.rkt:           (define turn (new turn% [current-state state]))
admin.rkt:           (in-sandbox-2
admin.rkt:            #:time (* (+ (length (state-players state)) 1) 3)
admin.rkt:            (lambda () (send external take-turn turn))
admin.rkt:            (lambda: ([tile : (Option Tile)] [hotel-involved : (Option Hotel)] [buy-shares : Shares-Order])
admin.rkt:                 (values IMPOSSIBLE (state-score state) (reverse (cons state states)))]
admin.rkt:                 (define merger? (eq? (what-kind-of-spot (state-board state) tile) MERGING))
admin.rkt:                   ;; -------------------------------------------------------------------------------
admin.rkt:                   [(and merger? (not (send turn place-called)))
admin.rkt:                    (loop (generate-tree (state-remove-current-player state)) (- n 1) states)]
admin.rkt:                   ;; -------------------------------------------------------------------------------
admin.rkt:                    (define-values (t1 h1 d*) (if merger? (send turn decisions) (values #f #f '())))
admin.rkt:                    (and (equal? tile t1) (equal? hotel-involved h1))
admin.rkt:                      [(member (state-current-player state) eliminate)
admin.rkt:                       ((failure state states (lambda: ([s : (Instance ATree%)]) (loop s  (- n 1) states)))
admin.rkt:                             (generate-tree (state-eliminate state eliminate))))
admin.rkt:                       (exec external (cast tree/eliminate (Instance LPlaced%)) tile hotel-involved d* buy-shares
admin.rkt:                             (lambda: ([next-tree : (Instance ATree%)] [state : State])
admin.rkt:                               (inform-all 
admin.rkt:                                next-tree state
admin.rkt:                                (lambda: ([next-tree : (Instance ATree%)] [state : State])
admin.rkt:                                    [(empty? (state-tiles state))
admin.rkt:                                     (values EXHAUSTED (state-score state) (reverse states))]
admin.rkt:                                    [else (loop next-tree (- n 1) (cons state states))]))))
admin.rkt:                             (failure state states (lambda (s) (loop s  (- n 1) states))))])])]))
admin.rkt:            (failure state states (lambda (s) (loop s  (- n 1) states))))])))
admin.rkt:    (: failure (State (Listof State) ((Instance ATree%) -> (Values Symbol Any (Listof State))) -> ((List Any Any) -> (Values Symbol Any (Listof State)))))
admin.rkt:      (log status `(turn failure  ,(player-name (state-current-player state))))
admin.rkt:      (define state/eliminate (state-remove-current-player state))
admin.rkt:      (if (empty? (state-players state/eliminate))
admin.rkt:          (continue (generate-tree state/eliminate)))) 
admin.rkt:    ;; [ (cons Tile [Listof Tile]) -> Tile ] -> Tree Tile [Maybe Hotel] Decisions [Listof Hotel]
admin.rkt:    ;; (Any -> Any) -- success continuation 
admin.rkt:    ;; (Any -> Any) -- failure continuation 
admin.rkt:    ;; -> Tree
admin.rkt:    (: exec : (Instance Player%) (Instance LPlaced%) Tile (Option Hotel) Decisions Shares-Order ((Instance ATree%) State -> (Values Any Any Any)) ((List Any Any) -> (Values Symbol Any (Listof State))) -> (Values Symbol Any (Listof State)))
admin.rkt:    (define/private (exec external tree0 placement hotel decisions shares-to-buy succ fail)
admin.rkt:      (define-values (tile tree) (tree-next tree0 placement hotel decisions shares-to-buy next-tile))
admin.rkt:      (in-sandbox-3 (lambda () (send external receive-tile (assert tile)))
admin.rkt:                  (lambda (_) (succ tree (tree-state tree)))
admin.rkt:    ;; State (Tree State -> Any)  -> Any 
admin.rkt:    (: inform-all ((Instance ATree%) State ((Instance ATree%) State -> (Values Any Any Any)) -> (Values Any Any Any)))
admin.rkt:    (define/private (inform-all tree state k)
admin.rkt:        (for/fold:  : (Listof Player) ((throw-out : (Listof Player) '())) ((p (state-players state)))
admin.rkt:          (in-sandbox-1 (lambda () (send (cast (player-external p) (Instance Player%)) inform state))
admin.rkt:                      (lambda (_) throw-out)
admin.rkt:                        (log status `(inform ,(player-name p)))
admin.rkt:                        (cons p throw-out)))))
admin.rkt:        [else (define state/eliminate (state-eliminate state eliminate))
admin.rkt:              (k (generate-tree state/eliminate) state/eliminate)]))
admin.rkt:    ;; -> [Listof InternalPlayer]
admin.rkt:    (: player->internals (-> (Listof Player)))
admin.rkt:    (define/private (player->internals)
admin.rkt:      #;(define-values (internals _)
admin.rkt:          (for/fold: : (Values Any Any) ((internals '()) (tile* ALL-TILES)) ((name+eplayer *named-players))
admin.rkt:            (define tiles (take tile* STARTER-TILES#))
admin.rkt:            (values (cons player internals) (drop tile* STARTER-TILES#))))
admin.rkt:               ((internals+tile* : (Pairof (Listof Player) (Listof Tile)) (cons '() ALL-TILES)))
admin.rkt:               ((name+eplayer : (List String (Instance Player%)) *named-players))
admin.rkt:               (define tiles (take (cdr internals+tile*) STARTER-TILES#))
admin.rkt:               (define player (build-player0 name tiles name+eplayer) #;(apply player0 name (append tiles (list (second name+eplayer)))))
admin.rkt:               (cons (cons player (car internals+tile*)) (drop (cdr internals+tile*) STARTER-TILES#)))))
admin.rkt:    ;; [Listof Player] State -> State
admin.rkt:    (: setup-all ((Listof Player) State -> State))
admin.rkt:    (define/private (setup-all players state)
admin.rkt:          (in-sandbox-1 (lambda () (send (cast (player-external p) (Instance Player%)) setup state))
admin.rkt:                          (log status `(setup ,(player-name p)))
admin.rkt:      (if (empty? misbehaving) state (state-eliminate state misbehaving)))
admin.rkt:    ;; State -> Void 
admin.rkt:    (: finish (State -> Void))
admin.rkt:      (define score (state-score state))
admin.rkt:      (for: ((e : Player (state-players state)))
admin.rkt:        (in-sandbox-1 (lambda () (send (cast (player-external e) (Instance Player%)) the-end state score)) 
admin.rkt:                      (log status `(end game ,(player-name e)))))))
admin.rkt:#;(define turn-administrator/c
admin.rkt:    (->m (listof player?)))
admin.rkt:   ;; ------------------------------------------------------------------------------------------------
admin.rkt:   (place-called
admin.rkt:    (->m boolean?))
admin.rkt:   ;; -------------------------------------------------------------------------------------------------
admin.rkt:    ;; -----------------------------------------------------------------------------------------------
admin.rkt:    ;; -----------------------------------------------------------------------------------------------
admin.rkt:    (->dm () #:pre (send this place-called)
admin.rkt:(define-type Turn%
admin.rkt:  (Class #:implements Turn-Administrator%
admin.rkt:         (init-field [current-state State])
admin.rkt:;  turn-administrator/c
admin.rkt:(: turn% Turn-Player%)
admin.rkt:    (init-field current-state)
admin.rkt:     [board   (state-board current-state)]
admin.rkt:     [current (state-current-player current-state)]
admin.rkt:     [cash    (player-money current)]
admin.rkt:     [tiles   (player-tiles current)]
admin.rkt:     [shares  (state-shares current-state)]
admin.rkt:     [hotels  (state-hotels current-state)]
admin.rkt:     [players (state-players current-state)])
admin.rkt:    (super-new)
admin.rkt:    (define/public (reconcile-shares t)
admin.rkt:      ;; (error 'reconcile-shares "not possible for local game play")
admin.rkt:    (define/public (place-called)
admin.rkt:      ;; -------------------------
admin.rkt:        ;; -------------------------
admin.rkt:        (define-values (acquirers acquired) (merging-which board tile))
admin.rkt:        (define acquired-hotels (append (remove hotel acquirers) acquired))
admin.rkt:        (let: keep-to-all : Any ((players : (Listof Player) players))
admin.rkt:            (in-sandbox-1 
admin.rkt:               (define ex (player-external p))
admin.rkt:                   (map (lambda (_) #t) acquired-hotels)
admin.rkt:                   (send (cast ex (Instance Player%)) keep acquired-hotels)))
admin.rkt:             (lambda: ([p-s-decisions : (Listof Boolean)])
admin.rkt:               (set! *decisions (cons (list p ((inst map (List Hotel Boolean) Hotel Boolean) (lambda: ([x : Hotel] [y : Boolean]) (list x y)) acquired-hotels p-s-decisions)) *decisions))
admin.rkt:               (keep-to-all (rest players)))
admin.rkt:               (log status `(keep failure ,(player-name p)))
admin.rkt:               (keep-to-all (rest players))))))
admin.rkt:        (define state/eliminated (state-eliminate current-state *eliminated))
admin.rkt:        (define state/returns (state-return-shares state/eliminated *decisions))
admin.rkt:        (set! current-state state/returns)
admin.rkt:        (state-players state/returns)))))
admin.rkt:    ;; --- the current player gets a bonus from the merger that enables it to buy shares 
admin.rkt:      (s3-merge-player-gets-bonus-can-buy (shares++ (shares++ player-shares0 TOWER) TOWER)))
admin.rkt:    (define turn (new turn% [current-state state]))
admin.rkt:    (check-true ((good-shares turn C3 TOWER) (list TOWER TOWER)))
admin.rkt:    ;; --- players return shares during the keep action that the current player can acquire
admin.rkt:    (define turn-subtle
admin.rkt:             (field (current-state
admin.rkt:                     (state-place-tile 
admin.rkt:                      (s3-merge-player-gets-bonus-can-buy (shares++ player-shares0 CONTINENTAL))
admin.rkt:             (super-new)
admin.rkt:             (define/public (place-called) #t))))
admin.rkt:    (check-true ((good-shares turn-subtle C3 TOWER) (list CONTINENTAL))))
basics-intf.rkt:;; ---------------------------------------------------------------------------------------------------
basics-intf.rkt:;; -- hotels
basics-intf.rkt:;; -- cash
basics-intf.rkt:;; -- shares 
basics-intf.rkt:;; -- plus functions that encode Acquire rules at this level
basics-intf.rkt:  [MIN-PLAYER# natural-number/c]
basics-intf.rkt:  [MAX-PLAYER# natural-number/c]
basics-intf.rkt:  [hotel?       (-> any/c boolean?)]
basics-intf.rkt:  [hotel<=?     (-> hotel? hotel? boolean?)]
basics-intf.rkt:  [random-hotel (-> hotel?)]
basics-intf.rkt:  [ALL-HOTELS   (and/c (listof hotel?) (sorted hotel<=?))]
basics-intf.rkt:  [SAFE#        natural-number/c] ;; a hotel that consists of at least SAFE# tiles is safe
basics-intf.rkt:  [FINAL#       natural-number/c] ;; a hotel that consists of at least FINAL# tiles ends the game 
basics-intf.rkt:  [string->hotel (-> string? (maybe/c hotel?))]
basics-intf.rkt:  [hotel->label  (-> hotel? string?)]
basics-intf.rkt:  [hotel->color  (-> hotel? symbol?)]
basics-intf.rkt:  [string->count (-> string? (maybe/c natural-number/c))]
basics-intf.rkt:  [xhotel?       (-> any/c boolean?)]
basics-intf.rkt:  [hotel->xexpr  (-> hotel? xhotel?)]
basics-intf.rkt:  [shares?            (-> any/c boolean?)]
basics-intf.rkt:  [banker-shares0     shares?]
basics-intf.rkt:  [player-shares0     shares?]
basics-intf.rkt:  [shares-order/c     contract?]
basics-intf.rkt:  [SHARES-PER-TURN#   natural-number/c]
basics-intf.rkt:  [shares++ (-> shares? hotel? shares?)]
basics-intf.rkt:  [shares-- (->i ((s shares?) (h hotel?)) #:pre (s h) (> (shares-available s h) 0) (r shares?))]
basics-intf.rkt:  [shares-available
basics-intf.rkt:    (-> shares? hotel? natural-number/c)]
basics-intf.rkt:  [shares-available?
basics-intf.rkt:    (-> shares? shares-order/c boolean?)]
basics-intf.rkt:  [shares-minus       (-> shares? shares? shares?)]
basics-intf.rkt:  [shares-plus        (-> shares? shares? shares?)]
basics-intf.rkt:  [shares-compatible  (-> shares? (-> shares? boolean?))]
basics-intf.rkt:  [shares->list       (-> shares? (listof hotel?))]
basics-intf.rkt:  [shares-combinable? (-> (listof shares?) boolean?)]
basics-intf.rkt:  [*combine-shares  (-> (and/c (listof shares?) shares-combinable?) shares?)]
basics-intf.rkt:  [*create-shares   (-> hotel? natural-number/c shares?)]
basics-intf.rkt:  [xshare?          (-> any/c boolean?)]
basics-intf.rkt:  [xshare<=?        (-> xshare? xshare? boolean?)]
basics-intf.rkt:  [shares->xexpr    (-> shares? (and/c (listof xshare?) (sorted xshare<=?)))]
basics-intf.rkt:  [xorder?          (-> any/c boolean?)]
basics-intf.rkt:  [shares->string   (-> shares? string?)]
basics-intf.rkt:  [order->xexpr     (-> shares-order/c xorder?)]
basics-intf.rkt:  [string->cash (-> string? (maybe/c cash?))]
basics-intf.rkt:  [cash->string (-> cash? string?)]
basics-intf.rkt:  [price-per-share
basics-intf.rkt:   (-> hotel? natural-number/c (maybe/c cash?))]
basics-intf.rkt:   (-> (or/c 'majority 'minority) hotel? natural-number/c cash?)])
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:(require "basics-intf.rkt")
basics.rkt: MIN-PLAYER#
basics.rkt: MAX-PLAYER#
basics.rkt: hotel? hotel<=? random-hotel 
basics.rkt: AMERICAN CONTINENTAL FESTIVAL IMPERIAL SACKSON TOWER WORLDWIDE ALL-HOTELS SAFE# FINAL# 
basics.rkt: string->hotel hotel->label hotel->color string->count xhotel? hotel->xexpr 
basics.rkt: shares? banker-shares0 player-shares0 shares-order/c SHARES-PER-TURN#
basics.rkt: shares++ shares-- shares-available shares-available? shares-minus shares-plus shares-compatible shares->list
basics.rkt: shares-combinable? *combine-shares *create-shares xshare? xshare<=? shares->xexpr xorder? shares->string
basics.rkt: order->xexpr
basics.rkt: cash? CASH0 string->cash cash->string
basics.rkt: price-per-share 
basics.rkt:(provide shares-order?)
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:(require "Lib/xml.rkt" "Lib/auxiliaries.rkt" (only-in srfi/1 list-index))
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:(define MIN-PLAYER# 3)
basics.rkt:(define MAX-PLAYER# 6)
basics.rkt:(define ALL-HOTELS HOTELS)
basics.rkt:(define random-hotel (lambda () (randomly-pick HOTELS)))
basics.rkt:;; Hotel -> Color 
basics.rkt:(define (hotel->color h)
basics.rkt:(define (string->hotel n)
basics.rkt:(define hotel->label values)
basics.rkt:  (xml-predicate (hotel ((label string->hotel)))))
basics.rkt:(define (hotel->xexpr h)
basics.rkt:  `(hotel ((label ,(hotel->label h)))))
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:(define SHARES-PER-TURN# 2)
basics.rkt:(define (all-equal? l) (or (empty? l) (andmap (curry equal? (first l)) (rest l))))
basics.rkt:(define shares-order/c (and/c (listof hotel?) all-equal? (compose (<=/c SHARES-PER-TURN#) length)))
basics.rkt:(define shares-order? (flat-contract-predicate shares-order/c))
basics.rkt:(define player-shares0 (for/fold ((s (hash))) ((h ALL-HOTELS)) (hash-set s h 0)))
basics.rkt:(define banker-shares0 (for/fold ((s (hash))) ((h ALL-HOTELS)) (hash-set s h SHARES0)))
basics.rkt:  (and (hash? s) (andmap (lambda (x) (member x HOTELS)) (hash-keys s)) #t))
basics.rkt:(define (shares-minus s t)
basics.rkt:  (for/fold ((s s)) ([(hotel n) t]) (hash-update s hotel (位 (m) (max 0 (- m n))))))
basics.rkt:(define (shares-plus s t)
basics.rkt:  (for/fold ((s s)) ([(hotel n) t]) (hash-update s hotel (位 (m) (+ m n)))))
basics.rkt:  (hash-update s h add1))
basics.rkt:(define (shares-- s h)
basics.rkt:  (hash-update s h sub1))
basics.rkt:(define (shares-available s h)
basics.rkt:  (hash-ref s h))
basics.rkt:(define (shares-available? available-s hotels)
basics.rkt:   (for/fold ((s available-s)) ((h hotels))
basics.rkt:     (and s (if (> (shares-available s h) 0) (shares-- s h) #f)))))
basics.rkt:;; Shares -> [Listof Hotel]
basics.rkt:(define (shares->list s)
basics.rkt:    (append (make-list count hotel) l)))
basics.rkt:;; [Listof Hotel] -> Shares 
basics.rkt:(define (list->shares hotels)
basics.rkt:  (for/fold ((s player-shares0)) ((h hotels)) (shares++ s h)))
basics.rkt:(define ((shares-compatible s) t)
basics.rkt:  (for/and ([(hotel count) t]) (>= (shares-available s hotel) count)))
basics.rkt:(define (string->count x)
basics.rkt:  (define n (string->number x))
basics.rkt:  (and n (exact-integer? n) (<= 0 n) (<= n SHARES0) n))
basics.rkt:(define (shares->string sh)
basics.rkt:  (string-join (for/list ([(h c) sh]) (format "~a : ~a " h c))))
basics.rkt:  (xml-predicate (share ((name string->hotel) (count string->count)))))
basics.rkt:(define (shares->xexpr s)
basics.rkt:    (sort (for/list ([(n c) s] #:when (> c 0)) `(,(hotel->label n) ,c))  string<=? #:key first))
basics.rkt:    (define-values (name count) (apply values share))
basics.rkt:    `(share ((name ,name) (count ,(number->string count))))))
basics.rkt:  (define hs ((xml-parser (share ((name values) (count values)) #:action name)) s))
basics.rkt:  (define ht ((xml-parser (share ((name values) (count values)) #:action name)) t))
basics.rkt:  (xml-predicate (order () xhotel? ...)))
basics.rkt:(define (order->xexpr o)
basics.rkt:  `(order () ,@(map hotel->xexpr o)))
basics.rkt:(define (*create-shares h n)
basics.rkt:  (for/fold ((s player-shares0)) ((i n)) (shares++ s h)))
basics.rkt:(define (shares-combinable? ls)
basics.rkt:  (for/and ([(key count) (foldr shares-plus player-shares0 ls)]) (<= count SHARES0)))
basics.rkt:(define (*combine-shares s)
basics.rkt:  (foldr shares-plus player-shares0 s))
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:(define cash? exact-nonnegative-integer? #;natural-number/c)
basics.rkt:(define (string->cash s)
basics.rkt:  (define n (string->number s))
basics.rkt:  (and n (exact-integer? n) (>= n 0) n))
basics.rkt:(define (cash->string c)
basics.rkt:  (number->string c))
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:  (define hotels-in-prices (apply set (apply append (rest (first PRICES)))))
basics.rkt:  (error 'PRICES "~a" (set-symmetric-difference hotels:set hotels-in-prices)))
basics.rkt:  (* (price-per-share hotel tile#) (if (eq? mode 'majority) 10 5)))
basics.rkt:(define (price-per-share hotel tile#)
basics.rkt:  (define limit-selector
basics.rkt:  (define limit* (reverse (map limit-selector table)))
basics.rkt:;; ---------------------------------------------------------------------------------------------------
basics.rkt:  (check-true (xorder? (order->xexpr '())))
basics.rkt:  (check-true (xorder? (order->xexpr (list AMERICAN))))
basics.rkt:  (check-true (xorder? (order->xexpr (list AMERICAN TOWER))))
basics.rkt:  (check-true (xorder? (order->xexpr (list AMERICAN TOWER FESTIVAL))))
basics.rkt:  (check-true ((shares-compatible banker-shares0) player-shares0))
basics.rkt:  (check-false ((shares-compatible player-shares0) banker-shares0))
basics.rkt:  (check-equal? (length (shares->list banker-shares0)) (* SHARES0 (length ALL-HOTELS)))
basics.rkt:  (check-equal? (length (shares->list player-shares0)) 0)
basics.rkt:  (check-true
basics.rkt:    (first (shares->xexpr (*create-shares AMERICAN 3)))
basics.rkt:    (first (shares->xexpr (*create-shares TOWER 4)))))
basics.rkt:  (check-false
basics.rkt:    (first (shares->xexpr (*create-shares TOWER 4)))
basics.rkt:    (first (shares->xexpr (*create-shares AMERICAN 3)))))
basics.rkt:  (define h0 (random-hotel))
basics.rkt:  (check-equal? (hash-ref (shares++ banker-shares0 h0) h0) (+ SHARES0 1))
basics.rkt:  (check-equal? (hash-ref (shares-- banker-shares0 h0) h0) (- SHARES0 1))
basics.rkt:  (check-equal? (shares-minus banker-shares0 player-shares0) banker-shares0)
basics.rkt:  (check-equal? (shares-minus banker-shares0 banker-shares0) player-shares0)
basics.rkt:  (check-true (andmap xshare? (shares->xexpr player-shares0)))
basics.rkt:  (check-true (andmap xshare? (shares->xexpr banker-shares0)))
basics.rkt:  (check-equal? (bonus 'majority AMERICAN 35) 10000)
basics.rkt:  (check-equal? (bonus 'minority CONTINENTAL 12) 4500)
basics.rkt:  (check-equal? (bonus 'majority SACKSON 4) 4000)
basics.rkt:  (check-equal? (price-per-share AMERICAN 35) 1000)
basics.rkt:  (check-equal? (price-per-share CONTINENTAL 12) 900)
basics.rkt:  (check-equal? (price-per-share SACKSON 4) 400)
board-intf.rkt:;; ---------------------------------------------------------------------------------------------------
board-intf.rkt:  [row?           (-> any/c boolean?)]
board-intf.rkt:  [string->row    (-> string? (maybe/c row?))]
board-intf.rkt:  [column?        (-> any/c boolean?)]
board-intf.rkt:  [string->column (-> string? (maybe/c column?))]
board-intf.rkt:  [tile           (-> column? row? any)]
board-intf.rkt:  [tile?   (-> any/c boolean?)]
board-intf.rkt:  [tile<=? (-> tile? tile? boolean?)]
board-intf.rkt:  [tile>?  (-> tile? tile? boolean?)]
board-intf.rkt:  [tile<?  (-> tile? tile? boolean?)]
board-intf.rkt:  [tile->string (-> tile? string?)]
board-intf.rkt:  [ALL-TILES      (and/c (listof tile?) (sorted tile<=?))]
board-intf.rkt:  [STARTER-TILES# natural-number/c]
board-intf.rkt:  [xtile?      (-> any/c boolean?)]
board-intf.rkt:  [tile->xexpr (-> tile? xtile?)]
board-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
board-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
board-intf.rkt:  [board?      (-> any/c boolean?)]
board-intf.rkt:  [board       (-> board?)]
board-intf.rkt:  [board-tiles (-> board? (listof tile?))]
board-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
board-intf.rkt:  [draw (-> board? image?)]
board-intf.rkt:  [draw-cell (-> tile? image?)]
board-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
board-intf.rkt:  [what-kind-of-spot
board-intf.rkt:   ;; -- founding a hotel <=> there is exactly one horizonatl or vertical 'free' tile 
board-intf.rkt:   ;; -- merging hotels <=> there are two distinct hotel neighbors 
board-intf.rkt:   ;; -- growing a hotel <=> there is one hotel heighbor 
board-intf.rkt:   ;; -- placing a singleton <=> no neighbors whatsoever 
board-intf.rkt:   ;; -- impossible: if the placement would cause a merger and involved a safe hotel 
board-intf.rkt:   (->i ((b board?) (t tile?))
board-intf.rkt:        #:pre/name (b t) "unoccupied spot" (free-spot? b t)
board-intf.rkt:  [growing-which
board-intf.rkt:   (->i ((b board?) (t tile?)) #:pre (b t) (eq? (what-kind-of-spot b t) GROWING) (hotel hotel?))]
board-intf.rkt:  [merging-which
board-intf.rkt:   (->i ((b board?) (t tile?)) #:pre/name (b t) "merger spot" (eq? (what-kind-of-spot b t) MERGING)
board-intf.rkt:        (values (acquirer (non-empty-listof hotel?)) (acquired (listof hotel?))))]
board-intf.rkt:  [size-of-hotel
board-intf.rkt:   (-> board? hotel? natural-number/c)]
board-intf.rkt:  [free-spot?
board-intf.rkt:   ;; is this spot unoccupied? (needed for contract of what-kind-of-spot)
board-intf.rkt:   (-> board? tile? boolean?)]
board-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
board-intf.rkt:  [merge-hotels 
board-intf.rkt:   (->i ((b board?) (t tile?) (h hotel?))
board-intf.rkt:        #:pre/name (b t) "tile designates a merger spot" (eq? (what-kind-of-spot b t) MERGING)
board-intf.rkt:        #:pre/name (b t h) "... a winner" (let-values ([(w _) (merging-which b t)]) (member h w))
board-intf.rkt:        (new-board board?))]
board-intf.rkt:  [found-hotel 
board-intf.rkt:   (->i ((b board?) (t tile?) (h hotel?)) #:pre (b t) (eq? (what-kind-of-spot b t) FOUNDING) 
board-intf.rkt:        (new-board board?))]
board-intf.rkt:  [grow-hotel 
board-intf.rkt:   (->i ((b board?) (t tile?)) #:pre (b t) (eq? (what-kind-of-spot b t) GROWING) 
board-intf.rkt:        (new-board board?))]
board-intf.rkt:  [place-tile
board-intf.rkt:   (->i ((b board?) (t tile?))
board-intf.rkt:        #:pre (b t) (memq (what-kind-of-spot b t) (list SINGLETON GROWING FOUNDING))
board-intf.rkt:        (new-board board?))]
board-intf.rkt:  [set-board 
board-intf.rkt:   ;; a derived function that re-discovers the appropriate situation and places a tile 
board-intf.rkt:   (->i ((b board?) (t tile?) (a [or/c FOUNDING GROWING MERGING SINGLETON]) (h (maybe/c hotel?)))
board-intf.rkt:        #:pre/name (b t) "good spot" (free-spot? b t)
board-intf.rkt:        (new-board board?))]
board-intf.rkt:   (-> board? shares-order/c cash? boolean?)]
board-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
board-intf.rkt:  [xboard?      (-> any/c boolean?)]
board-intf.rkt:  [board->xexpr (-> board? xboard?)]
board-intf.rkt:  [xspot?       (-> any/c boolean?)]
board-intf.rkt:  [spot->xexpr  (-> board? tile? [or/c SINGLETON FOUNDING GROWING MERGING IMPOSSIBLE] xspot?)]
board-intf.rkt:  [*create-board-with-hotels
board-intf.rkt:   (->i ([t (and/c (listof tile?) distinct)] 
board-intf.rkt:         [lh (t) (and/c (listof (cons/c hotel? (listof tile?))) (distinct-and-properly-formed t))])
board-intf.rkt:  [distinct-and-properly-formed
board-intf.rkt:   (->i ((free-tiles (listof tile?))) 
board-intf.rkt:        (check-hotels 
board-intf.rkt:         (->i ((hotels-as-lists (listof (cons/c hotel? (listof tile?))))) (ok boolean?))))]
board-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
board-intf.rkt:  board-a1-b2-c6 
board-intf.rkt:  board-a2-b2-american
board-intf.rkt:  board-b2-c2-am-c4-d4-tw-e4
board-intf.rkt:  board-3way-merger-at-d3)
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:;; -- inspecting the board to strategize 
board.rkt:;; -- placing tiles on the board to realize a player's action 
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:(require "board-intf.rkt")
board.rkt:(basics& row? string->row column? string->column tile ctile
board.rkt:         tile? tile<=? tile>? tile<? tile->string
board.rkt:         ALL-TILES STARTER-TILES#
board.rkt:         xtile? tile->xexpr 
board.rkt:         board? board board-tiles 
board.rkt:         draw draw-cell
board.rkt:         what-kind-of-spot growing-which merging-which size-of-hotel free-spot?
board.rkt:         merge-hotels found-hotel grow-hotel place-tile set-board affordable?
board.rkt:         xboard? board->xexpr xspot? spot->xexpr
board.rkt:         *create-board-with-hotels distinct-and-properly-formed
board.rkt:         board-a1-b2-c6 board-a2-b2-american board-b2-c2-am-c4-d4-tw-e4 board-3way-merger-at-d3)
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:  (provide (all-defined-out))
board.rkt:  (require "basics.rkt" "Lib/auxiliaries.rkt" "Lib/xml.rkt" 2htdp/image (only-in srfi/1 list-index))
board.rkt:  ;; ---------------------------------------------------------------------------------------------------
board.rkt:  (define COLUMNS (stream->list (in-range 1 13 1)))
board.rkt:  (define (random-column) (randomly-pick COLUMNS))
board.rkt:  (define (column-> c)
board.rkt:    (if (eq? (last COLUMNS) c) #f (list-ref COLUMNS (+ (list-index (curry eq? c) COLUMNS) 1))))
board.rkt:  (define (column-< c)
board.rkt:    (if (eq? (first COLUMNS) c) #f (list-ref COLUMNS (- (list-index (curry eq? c) COLUMNS) 1))))
board.rkt:  ;; Column Column -> Boolean 
board.rkt:  (define (column->text c)
board.rkt:    (text/font (number->string c) 24 "black" #f 'system 'normal 'normal #f))
board.rkt:  (define (string->column s)
board.rkt:           (define n (string->number s))
board.rkt:  (define (column->string c)
board.rkt:    (number->string c))
board.rkt:  (define (random-row) (randomly-pick ROWS))
board.rkt:  (define (row-^ r)
board.rkt:    (if (eq? (first ROWS) r) #f (list-ref ROWS (- (list-index (curry eq? r) ROWS) 1))))
board.rkt:  (define (row-v r)
board.rkt:    (if (eq? (last ROWS)  r) #f (list-ref ROWS (+ (list-index (curry eq? r) ROWS) 1))))
board.rkt:  ;; Row Row -> Boolean 
board.rkt:    (<= (list-index (curry eq? q) ROWS) (list-index (curry eq? r) ROWS)))
board.rkt:  ;; Row Row -> Boolean 
board.rkt:    (< (list-index (curry eq? q) ROWS) (list-index (curry eq? r) ROWS)))
board.rkt:  (define (row->text r)
board.rkt:    (text/font  (symbol->string r) 24 "black" #f 'system 'normal 'normal #f))
board.rkt:  (define (string->row s)
board.rkt:           (define n (string->symbol s))
board.rkt:  (define (row->string r)
board.rkt:    (symbol->string r))
board.rkt:  (define CELL-SIZE 66)
board.rkt:  ;; ---------------------------------------------------------------------------------------------------
board.rkt:  ;; (struct tile (column row) #:prefab-as-list)
board.rkt:  (define TILE-SIZE (- CELL-SIZE 3))
board.rkt:  (define TILE-COLOR 'gray)
board.rkt:  (define STARTER-TILES# 6)
board.rkt:  (define-syntax-rule
board.rkt:  ;; (-> column? row? any)
board.rkt:  (define tile-column first)
board.rkt:  (define tile-row second)
board.rkt:    (and (pair? t) (pair? (rest t)) (null? (cddr t)) (row? (tile-row t)) (column? (tile-column t)) #t))
board.rkt:  (define ALL-TILES 
board.rkt:  ;; Tile Tile -> Boolean 
board.rkt:  ;; is t1 closer to the top-left corner than t2? 
board.rkt:    (or (row<< (tile-row t1) (tile-row t2))
board.rkt:        (and (row<= (tile-row t1) (tile-row t2))
board.rkt:             (column<= (tile-column t1) (tile-column t2)))))
board.rkt:  (define (tile->string t)
board.rkt:    (format "(~a,~a)" (tile-column t) (tile-row t)))
board.rkt:    (xml-predicate (tile ((column string->column) (row string->row)))))
board.rkt:  (define (tile->xexpr t)
board.rkt:    `(tile ((column ,(column->string (tile-column t))) (row ,(row->string (tile-row t))))))
board.rkt:  (define (draw-grid f)
board.rkt:    (define rows-of-columns 
board.rkt:            (overlay (draw-cell c r) (f c r) (square CELL-SIZE 'outline 'black))))
board.rkt:    (apply above rows-of-columns))
board.rkt:  (define (draw-tile c r)
board.rkt:    (square TILE-SIZE 'solid TILE-COLOR))
board.rkt:  (define draw-cell
board.rkt:    (let* ([row-width (apply max (map (compose image-width row->text) ROWS))]
board.rkt:           [col-width (apply max (map (compose image-width column->text) COLUMNS))]
board.rkt:           [height    (image-height (row->text (first ROWS)))]
board.rkt:           [space     (rectangle (+ col-width 2 row-width) height transprnt 'white)])
board.rkt:      (case-lambda 
board.rkt:        [(t) (draw-cell (tile-column t) (tile-row t))]
board.rkt:         (let* ([c (column->text c)]
board.rkt:                [r (row->text r)]
board.rkt:                [x (- col-width (image-width c))]
board.rkt:                [i (place-image/align c x 0 'left 'top space)]
board.rkt:                [x (+ col-width (quotient (- row-width (image-width r)) 2) 1)]
board.rkt:                [i (place-image/align r x 0 'left 'top i)])
board.rkt:  (define (draw-hotel h)
board.rkt:    (define c (hotel->color h))
board.rkt:    (overlay (above (text (hotel->label h) 11 c)
board.rkt:                    (square (+ 22 (image-height (column->text (first COLUMNS)))) 'solid 'white))
board.rkt:             (square (- CELL-SIZE 10) 'solid 'white)
board.rkt:             (square (- CELL-SIZE 2) 'solid c))))
board.rkt:  (require (for-syntax racket/syntax (only-in  (submod ".." tiles) ROWS COLUMNS))
board.rkt:           (only-in (submod ".." tiles) ctile))
board.rkt:  (define-syntax (define-all-tiles stx)
board.rkt:             (define rc (datum->syntax stx (format-symbol "~a~a" r c)))
board.rkt:  (define-all-tiles))
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:(define TAKEN-NO-HOTEL 'taken-ho-hotel)
board.rkt:;; Content = Hotel | UNTAKEN | TAKEN-NO-HOTEL
board.rkt:(define (board-tiles b) (hash-keys b))
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:;; Tile *-> Board 
board.rkt:  (for/fold ((b #hash())) ((t (in-list t*)))
board.rkt:    (place-tile b t)))
board.rkt:(define (*create-board-with-hotels lt lh)
board.rkt:      (hash-set b t name))))
board.rkt:;; Board Column Row -> Content
board.rkt:(define (board-ref b c r)
board.rkt:  (hash-ref b (tile c r) UNTAKEN))
board.rkt:;; Board Column Row -> Content 
board.rkt:(define (board-set b c r [h TAKEN-NO-HOTEL])
board.rkt:  (hash-set b (tile c r) h))
board.rkt:;; Board Column Row [X X X X ->* Y] ->* Y 
board.rkt:(define (cardinal-direction n-s e-w)
board.rkt:    (define north-south (n-s r))
board.rkt:    (define east-west (e-w c))
board.rkt:      [(boolean? north-south) UNTAKEN]
board.rkt:      [(boolean? east-west) UNTAKEN]
board.rkt:      [else (board-ref b east-west north-south)])))
board.rkt:(define north (cardinal-direction row-^ values))
board.rkt:(define south (cardinal-direction row-v values))
board.rkt:(define east (cardinal-direction values column->))
board.rkt:(define west (cardinal-direction values column-<))
board.rkt:;; Board Hotel -> [Listof Tile] | sorted * tile<=?
board.rkt:(define (tiles-with-specific-label b h)
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:(define (free-spot? board tile)
board.rkt:  (eq? (board-ref board (tile-column tile) (tile-row tile)) UNTAKEN))
board.rkt:(define (what-kind-of-spot board tile)
board.rkt:  (define column (tile-column tile))
board.rkt:  (define row (tile-row tile))
board.rkt:  (define hotels# (set-count hotels))
board.rkt:  (define neighbor-taken-no-hotel? (ormap (curry eq? TAKEN-NO-HOTEL) surroundings))
board.rkt:    [(= hotels# 0) (if neighbor-taken-no-hotel? FOUNDING SINGLETON)]
board.rkt:    [(= hotels# 1) (if neighbor-taken-no-hotel? IMPOSSIBLE GROWING)]
board.rkt:     (define any-hotel-safe? (for/or ((h hotels)) (>= (size-of-hotel board h) SAFE#)))
board.rkt:     (if (or neighbor-taken-no-hotel? any-hotel-safe?) IMPOSSIBLE MERGING)]))
board.rkt:(define (growing-which board tile)
board.rkt:  (first (filter hotel? (neighbors board (tile-column tile) (tile-row tile) list))))
board.rkt:(define (merging-which board tile)
board.rkt:  (define surroundings (neighbors board (tile-column tile) (tile-row tile) list))
board.rkt:  (define hotels (set->list (apply set (filter hotel? surroundings))))
board.rkt:  (define sorted (sort (map (lambda (h) (list h (size-of-hotel board h))) hotels) > #:key second))
board.rkt:(define (size-of-hotel board hotel)
board.rkt:  (for/fold ((size 0)) ([(key value) (in-hash board)])
board.rkt:(define (grow-hotel board tile)
board.rkt:  (define row (tile-row tile))
board.rkt:  (define column (tile-column tile))
board.rkt:  (define hotel-that-touches (first (filter hotel? surroundings)))
board.rkt:  (board-set board column row hotel-that-touches))
board.rkt:(define (merge-hotels board tile hotel)
board.rkt:  (define row (tile-row tile))
board.rkt:  (define column (tile-column tile))
board.rkt:  (define-values (acquirers acquired) (merging-which board tile))
board.rkt:  (define acquired-hotels (append (remq hotel acquirers) acquired))
board.rkt:  (define relabeled-hotel
board.rkt:    (for/hash (([key current-content] (in-hash board)))
board.rkt:      (if (memq current-content acquired-hotels)
board.rkt:          (values key current-content))))
board.rkt:  (board-set relabeled-hotel column row hotel))
board.rkt:(define (found-hotel board tile hotel)
board.rkt:  (define row (tile-row tile))
board.rkt:  (define column (tile-column tile))
board.rkt:  (board-set (hotel-take-over-neighboring-tiles board column row hotel) column row hotel))
board.rkt:;; Board Column Row Hotel -> Board 
board.rkt:;; mark all TAKEN-NO-HOTEL tiles on board reachable from (column,row) as belong to hotel
board.rkt:(define (hotel-take-over-neighboring-tiles board column row hotel)
board.rkt:  (let loop ((board board) (to-visit (list (tile column row))) (visited '()))
board.rkt:      [(empty? to-visit) board]
board.rkt:      [(member (first to-visit) visited) (loop board (rest to-visit) visited)]
board.rkt:       (define column (tile-column (first to-visit)))
board.rkt:       (define row (tile-row (first to-visit)))
board.rkt:       (define-values (n e s w) (neighbors board column row values))
board.rkt:       (loop (board-set board column row hotel)
board.rkt:             (append (if (equal? TAKEN-NO-HOTEL n) (list (tile column (row-^ row))) '())
board.rkt:                     (if (equal? TAKEN-NO-HOTEL e) (list (tile (column-> column) row)) '())
board.rkt:                     (if (equal? TAKEN-NO-HOTEL s) (list (tile column (row-v row))) '())
board.rkt:                     (if (equal? TAKEN-NO-HOTEL w) (list (tile (column-< column) row)) '())
board.rkt:                     (rest to-visit))
board.rkt:             (cons (first to-visit) visited))])))
board.rkt:(define (place-tile board tile)
board.rkt:  (define row (tile-row tile))
board.rkt:  (define column (tile-column tile))
board.rkt:  (board-set board column row))
board.rkt:(define (set-board board tile kind hotel)
board.rkt:    [(eq? FOUNDING kind) (if hotel (found-hotel board tile hotel) (place-tile board tile))]
board.rkt:    [(eq? MERGING kind) (merge-hotels board tile hotel)]
board.rkt:    [(eq? SINGLETON kind) (place-tile board tile)]
board.rkt:    [(eq? GROWING kind) (grow-hotel board tile)]))
board.rkt:  (define prices (map (lambda (h) (price-per-share h (size-of-hotel board h))) hotels))
board.rkt:  (draw-grid (lambda (c r) 
board.rkt:               (define content (board-ref board c r))
board.rkt:                 [(hotel? content) (draw-hotel content)]
board.rkt:                 [(equal? TAKEN-NO-HOTEL content) (draw-tile c r)]
board.rkt:                 [else (draw-cell c r)]))))
board.rkt:(define xboard? (xml-predicate (board () xtile? ... xboard-hotel? ...)))
board.rkt:(define xboard-hotel? (xml-predicate (hotel ((name string->hotel)) xtile? ...)))
board.rkt:(define (board->xexpr b)
board.rkt:  (define unassociated-tiles (map tile->xexpr #;"is sorted" (tiles-with-specific-label b TAKEN-NO-HOTEL)))
board.rkt:  (define tiles-per-hotel (lambda (h) #;"is sorted" (tiles-with-specific-label b h)))
board.rkt:  (define hotels-of-tiles 
board.rkt:             (define tiles #;"is sorted" (tiles-per-hotel h))
board.rkt:                 (cons `(hotel ((name ,(hotel->label h))) ,@(map tile->xexpr tiles)) others)))
board.rkt:           ALL-HOTELS))
board.rkt:  ;; -- IN -- 
board.rkt:  `(board () ,@unassociated-tiles ,@hotels-of-tiles))
board.rkt:  (let ((h? string->hotel))
board.rkt:    (xml-predicate
board.rkt:(define (spot->xexpr b tile kind)
board.rkt:    [(eq? GROWING kind) `(growing ((name ,(hotel->label (growing-which b tile)))))]
board.rkt:     (define-values (acquirers acquired) (merging-which b tile))
board.rkt:         `(merging ((acquirer ,(hotel->label (first acquirers)))
board.rkt:                    ,@(numbered-attributes "acquired~a" hotel->label acquired))))]
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:  (check-equal? (column-> (first COLUMNS)) (second COLUMNS))
board.rkt:  (check-equal? (column-< (first COLUMNS)) #f)
board.rkt:  (check-equal? (column-> (last COLUMNS)) #f)
board.rkt:  (check-equal? (column-< (last COLUMNS)) (second (reverse COLUMNS)))
board.rkt:  (check-equal? (row-^ (first ROWS)) #f)
board.rkt:  (check-equal? (row-^ (last ROWS))  (second (reverse ROWS)))
board.rkt:  (check-equal? (row-v (first ROWS)) (second ROWS))
board.rkt:  (check-equal? (row-v (last ROWS))  #f)
board.rkt:  (check-true (tile<=? (ctile A 1) (ctile A 1)))
board.rkt:  (check-true (tile<=? (ctile A 1) (ctile A 2)))
board.rkt:  (check-true (tile<=? (ctile A 2) (ctile B 1)))
board.rkt:  (check-true (tile<=? (ctile A 2) (ctile B 8)))
board.rkt:  (check-false (tile<=? (ctile A 2) (ctile A 1)))
board.rkt:  (check-false (tile<=? (ctile C 2) (ctile B 1)))
board.rkt:  (check-true (tile? (ctile A 1)))
board.rkt:  (define (draw-random-board)
board.rkt:    (draw-grid (lambda (c r) 
board.rkt:                   [(< (random 10) 2) (draw-hotel (random-hotel))]
board.rkt:                   [(< (random 10) 2) (draw-cell c r)]
board.rkt:                   [else (draw-tile c r)]))))
board.rkt:  (draw-random-board)
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:(define-syntax (define-board stx)
board.rkt:  (syntax-case stx ()
board.rkt:     (with-syntax ([it (datum->syntax stx 'it)])
board.rkt:     (with-syntax ([it (datum->syntax stx 'it)])
board.rkt:(define-board board-a1-b2-c6 (A1 B2 C6))
board.rkt:(define-board board-a2-b2-american (B2)
board.rkt:  (found-hotel it A2 AMERICAN))
board.rkt:(define-board board-b2-c2-am-c4-d4-tw-e4  (B2 D4)
board.rkt:  (found-hotel it C2 AMERICAN)
board.rkt:  (found-hotel it C4 TOWER)
board.rkt:  (grow-hotel  it E4))
board.rkt:(define-board board-safe-american #:inherit board-b2-c2-am-c4-d4-tw-e4
board.rkt:  (foldl (lambda (t b) (grow-hotel b t)) it (list B4 F4 G4 H4 I4 A4 F5 G5 H5 I5)))
board.rkt:(define-board board-b2-c2-am-b4-c4-tw-d2-d4-e3 (B2 B4)
board.rkt:  (found-hotel it C2 AMERICAN)
board.rkt:  (found-hotel it C4 TOWER)
board.rkt:  (grow-hotel  it D2)
board.rkt:  (grow-hotel  it D4)
board.rkt:  (let ([s (what-kind-of-spot it E3)])
board.rkt:        (error 'board-b2-c2-am-b4-c4-tw-d4-a3 "(E,3) bad: ~e" s)))
board.rkt:  (place-tile  it E3))
board.rkt:(define-board board-3way-merger-at-d3 #:inherit board-b2-c2-am-b4-c4-tw-d2-d4-e3
board.rkt:  (found-hotel it F3 WORLDWIDE)
board.rkt:  (let-values ([(acquirer acquired) (merging-which it D3)])
board.rkt:        (error 'board-3way-merger-at-d3 "(D,3) bad: ~e" (append acquirer acquired)))))
board.rkt:D5, D6 - hotel           
board.rkt:D8, D9 - hotel
board.rkt:(define-board d5-d6-tw-d8-d9-am (D5 D8)
board.rkt:  (found-hotel it D6 TOWER)
board.rkt:  (found-hotel it D9 AMERICAN)
board.rkt:  (place-tile it E7))
board.rkt:(define-board d1-should-merge (C1 E1 D2)
board.rkt:  (place-tile it F2)
board.rkt:  (found-hotel it B1 TOWER)
board.rkt:  (found-hotel it D3 AMERICAN)
board.rkt:  (found-hotel it F1 FESTIVAL))
board.rkt:  (check-equal? (what-kind-of-spot d1-should-merge D1) MERGING)
board.rkt:  (check-equal? (what-kind-of-spot d5-d6-tw-d8-d9-am D7) IMPOSSIBLE "due to Patrick and Deanna")
board.rkt:  (define b (*create-board-with-hotels (list A2) '()))
board.rkt:  (check-equal? (free-spot? b A1) #t)
board.rkt:  (check-equal? (what-kind-of-spot b A1) FOUNDING)
board.rkt:  ;; -------------------------------------------------------------------------------------------------
board.rkt:  (define empty-board (board))
board.rkt:  (check-true (board? empty-board))
board.rkt:  (check-true (free-spot? empty-board (tile (random-column) (random-row))))
board.rkt:  (check-equal? (what-kind-of-spot empty-board (tile (random-column) (random-row))) SINGLETON)
board.rkt:  (check-equal? (size-of-hotel empty-board (random-hotel)) 0)
board.rkt:  (check-equal? (what-kind-of-spot (board* B2) A1) SINGLETON)
board.rkt:  (check-equal? (what-kind-of-spot (board* B2) A2) FOUNDING)
board.rkt:  ;; -------------------------------------------------------------------------------------------------
board.rkt:  (check-false (free-spot? board-a1-b2-c6 A1))
board.rkt:  (check-equal? (what-kind-of-spot board-a1-b2-c6 A2) FOUNDING) ;; <--- QUESTION?
board.rkt:  (check-equal? (what-kind-of-spot board-a1-b2-c6 D6) FOUNDING)
board.rkt:  (check-equal? (what-kind-of-spot board-a1-b2-c6 C5) FOUNDING)
board.rkt:  (check-equal? (what-kind-of-spot board-a1-b2-c6 B6) FOUNDING)
board.rkt:  (check-equal? (what-kind-of-spot board-a1-b2-c6 C4) SINGLETON)
board.rkt:  (check-equal? (what-kind-of-spot board-safe-american C3) IMPOSSIBLE)
board.rkt:  (check-equal? (what-kind-of-spot board-safe-american B3) IMPOSSIBLE)
board.rkt:  ;; -------------------------------------------------------------------------------------------------
board.rkt:  (check-true (board? board-a2-b2-american))
board.rkt:  (check-equal? (size-of-hotel board-a2-b2-american AMERICAN) 2)
board.rkt:  (check-equal? (what-kind-of-spot board-a2-b2-american C2) GROWING)
board.rkt:  (check-equal? (what-kind-of-spot board-a2-b2-american B1) GROWING)
board.rkt:  (check-equal? (what-kind-of-spot board-a2-b2-american A1) GROWING)
board.rkt:  (define board-1-hotel-grown (grow-hotel board-a2-b2-american A1))
board.rkt:  (check-true (board? board-1-hotel-grown))
board.rkt:  (check-equal? (what-kind-of-spot board-a2-b2-american B1) GROWING)
board.rkt:  (check-equal? (what-kind-of-spot board-a2-b2-american C2) GROWING)
board.rkt:  ;; -------------------------------------------------------------------------------------------------
board.rkt:  (check-true (board? board-b2-c2-am-c4-d4-tw-e4))
board.rkt:  (check-equal? (size-of-hotel board-b2-c2-am-c4-d4-tw-e4 AMERICAN) 2)
board.rkt:  (check-equal? (size-of-hotel board-b2-c2-am-c4-d4-tw-e4 TOWER) 3)
board.rkt:  (check-equal? (what-kind-of-spot board-b2-c2-am-c4-d4-tw-e4 C3) MERGING)
board.rkt:  (call-with-values (lambda () (merging-which board-b2-c2-am-c4-d4-tw-e4 C3))
board.rkt:                      (check-equal? winners (list TOWER))
board.rkt:                      (check-equal? losers  (list AMERICAN))))
board.rkt:  (define board-merged (merge-hotels board-b2-c2-am-c4-d4-tw-e4 C3 TOWER))
board.rkt:  (check-true (board? board-merged))
board.rkt:  (check-equal? (size-of-hotel board-merged TOWER) 6)
board.rkt:  (define board-merged-3way (merge-hotels board-3way-merger-at-d3 D3 TOWER))
board.rkt:  (check-true (board? board-merged-3way))
board.rkt:  (check-equal? (size-of-hotel board-merged-3way TOWER) 9)
board.rkt:  ;; -------------------------------------------------------------------------------------------------
board.rkt:  (check-equal? (what-kind-of-spot board-b2-c2-am-b4-c4-tw-d2-d4-e3 D3) IMPOSSIBLE)
board.rkt:  (define board-b2-c2-am-b4-c4-tw-d4-e3-d3 (merge-hotels board-b2-c2-am-b4-c4-tw-d2-d4-e3 D3 TOWER))
board.rkt:  ;; ---------------------------------------------------------------------------------------------------
board.rkt:  (check-equal? (board->xexpr (board)) '(board ()))
board.rkt:  (check-equal? (board->xexpr board-a1-b2-c6) 
board.rkt:                `(board () ,@(map tile->xexpr (list A1 B2 C6))))
board.rkt:  (check-equal? (board->xexpr board-a2-b2-american)
board.rkt:                `(board () (hotel ((name ,(hotel->label AMERICAN))) ,@(map tile->xexpr (list A2 B2)))))
board.rkt:  (check-equal? (board->xexpr board-b2-c2-am-c4-d4-tw-e4 )
board.rkt:                        (hotel ((name ,(hotel->label AMERICAN))) ,@(map tile->xexpr (list B2 C2)))
board.rkt:                        (hotel ((name ,(hotel->label TOWER))) ,@(map tile->xexpr (list C4 D4 E4)))))
board.rkt:  (check-equal? (board->xexpr board-b2-c2-am-b4-c4-tw-d2-d4-e3)
board.rkt:                        ,(tile->xexpr E3)
board.rkt:                        (hotel ((name ,(hotel->label AMERICAN))) ,@(map tile->xexpr (list B2 C2 D2)))
board.rkt:                        (hotel ((name ,(hotel->label TOWER))) ,@(map tile->xexpr (list B4 C4 D4)))))
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:(define ((distinct-and-properly-formed free-tiles) hotels-as-lists)
board.rkt:  (define hotel-tiles (map rest hotels-as-lists))
board.rkt:  (and (or (distinct (map first hotels-as-lists)) (tee/#f "hotel names not distinct"))
board.rkt:       (or (andmap contains-at-least-two hotel-tiles) (tee/#f "hotels don't have 2 tiles"))
board.rkt:       (or (distinct (apply append free-tiles hotel-tiles)) (tee/#f "hotel & free tiles overlap"))
board.rkt:       (or (andmap connected-graph hotel-tiles) (tee/#f "hotels not graphs"))
board.rkt:       (or (no-two-hotels-touch hotel-tiles) (tee/#f "two hotels touch"))))
board.rkt:;; ---------------------------------------------------------------------------------------------------
board.rkt:;; HT = (cons Tile (cons Tile [Listof Tile])) ;; the tiles of a syntactically well-formed hotel 
board.rkt:;; HT -> Boolean 
board.rkt:(define (contains-at-least-two ht)
board.rkt:;; HT -> Boolean 
board.rkt:(define (connected-graph hotel-tiles)
board.rkt:  (define start (first hotel-tiles))
board.rkt:  (define remaining (rest hotel-tiles))
board.rkt:  (define next (connected-to start remaining))
board.rkt:           [else (define one-step (apply append (map (位 (f) (connected-to f remaining)) frontier)))
board.rkt:                 (and (cons? one-step) (loop one-step (remove* one-step remaining)))]))))
board.rkt:;; [Listof HT] -> Boolean 
board.rkt:(define (no-two-hotels-touch hotel-tiles*)
board.rkt:  (and-over-pairs-of-distinct-hotels 
board.rkt:   (lambda (one other) (not (connected-graph (append one other))))
board.rkt:   hotel-tiles*))
board.rkt:;; [HT HT -> Boolean] [Listof HT] -> Boolean
board.rkt:(define (and-over-pairs-of-distinct-hotels f hotel-tiles*)
board.rkt:  (or (empty? hotel-tiles*)
board.rkt:      (let loop ([preceding '()][current (first hotel-tiles*)][remaining (rest hotel-tiles*)])
board.rkt:;; Tile HT -> [Listof Tile]
board.rkt:(define (connected-to t hotel-tiles*)
board.rkt:  (define r (tile-row t))
board.rkt:  (define c (tile-column t))
board.rkt:    (cond [(and r c (member (tile c r) hotel-tiles*)) => (compose list first)] [else '()]))
board.rkt:  (append (in (row-^ r) c) (in (row-v r) c) (in r (column-> c)) (in r (column-< c))))
board.rkt:  ;; connected-to 
board.rkt:  (check-equal? (connected-to (ctile A 1) (list (ctile A 2) (ctile C 4) (ctile B 1)))
board.rkt:  (check-equal? (connected-to (ctile A 1) '()) '())
board.rkt:  ;; connected-spots
board.rkt:  (check-false (connected-graph (list  (ctile A 1) (ctile A 2) (ctile C 4) (ctile B 1))))
board.rkt:  (check-true (connected-graph (list  (ctile A 1) (ctile C 2) (ctile A 2) (ctile B 2))))
board.rkt:  ;; distinct-and-properly-formed 
board.rkt:  (define hotel-1 (hotel AMERICAN))
board.rkt:  (define hotel-2 (hotel CONTINENTAL))
board.rkt:  (check-true ((distinct-and-properly-formed '()) (list hotel-2 american)))
board.rkt:  (check-false ((distinct-and-properly-formed '()) (list (list AMERICAN))))
board.rkt:  (check-false ((distinct-and-properly-formed '()) (list (list* AMERICAN (list (ctile A 1))))))
board.rkt:  (check-false ((distinct-and-properly-formed '()) (list hotel-1 american)))
board.rkt:  (check-false ((distinct-and-properly-formed tiles) (list hotel-2 american)))
board.rkt:  (check-true ((distinct-and-properly-formed (list (ctile A 6))) (list hotel-2 american)))
board.rkt:  (check-false ((distinct-and-properly-formed '()) (list hotel-1 hotel-2))))
client-start.rkt:exec racket -tm "$0" ${1+"$@"}
client-start.rkt:;; ---------------------------------------------------------------------------------------------------
client-start.rkt:;;   $ ./client-start HOST PORT NAME-of-player 
client-start.rkt:  ;; $ ./client-start.rkt ip-or-hostname port# name 
client-start.rkt:  ;; create random player (name) and connect to Acquire server at ip-or-hostname on port#
client-start.rkt:  (rename-out (make-player main)))
client-start.rkt:;; ---------------------------------------------------------------------------------------------------
client-start.rkt:(require "player.rkt" "strategy.rkt" "remote-admin.rkt")
client-start.rkt:(define (make-player host port name)
client-start.rkt:  (define player (create name random-s))
client-start.rkt:  (define-values (in out) (tcp-connect host (string->number port)))
client-start.rkt:  (define remote-administrator (new remote-administrator% [in in][out out]))
client-start.rkt:  (send player go remote-administrator)
client-start.rkt:  (send remote-administrator show-players)
client-start.rkt:  (send remote-administrator run 0)) 
client-start.rkt:;; --- test run 
client-start.rkt:  (define c (make-custodian))
client-start.rkt:  (define all-threads
client-start.rkt:    (parameterize ((current-custodian c))
client-start.rkt:           (define-values (status score _state) (make-player HOST PORT name)) 
client-start.rkt:  (let wait ((l all-threads))
client-start.rkt:  (custodian-shutdown-all c))
game-intf.rkt:;; ---------------------------------------------------------------------------------------------------
game-intf.rkt: "admin.rkt" "basics.rkt" "board.rkt" (only-in "state.rkt" state?) "player.rkt" "Lib/contract.rkt")
game-intf.rkt:   (->i ((lp (and/c (listof player?) (lambda (lp) (<= MIN-PLAYER# (length lp) MAX-PLAYER#))))
game-intf.rkt:         (n natural-number/c))
game-intf.rkt:        (#:show (show (-> natural-number/c board? any)))
player-factory.rkt:;; ---------------------------------------------------------------------------------------------------
player-factory.rkt:(require (only-in "player.rkt" player?) "admin-intf.rkt")
player-factory.rkt: (contract-out 
player-factory.rkt:  (random-players (-> natural-number/c (listof player?)))
player-factory.rkt:  (ordered-players (-> natural-number/c (listof player?)))
player-factory.rkt:  (merge-bad-player (-> (instanceof/c player/c)))
player-factory.rkt:  (keep-bad-player (-> (instanceof/c player/c)))
player-factory.rkt:  (end-bad-player (-> (instanceof/c player/c)))
player-factory.rkt:  (receive-bad-player (-> (instanceof/c player/c)))
player-factory.rkt:  (setup-bad-player (-> (instanceof/c player/c)))
player-factory.rkt:  (inform-bad-player (-> (instanceof/c player/c)))
player-factory.rkt:  (inf-loop-player (-> natural-number/c player?))))
player-factory.rkt:;; ---------------------------------------------------------------------------------------------------
player-factory.rkt:(define (ordered-players n) (players ordered-s n))
player-factory.rkt:(define (random-players n) (players random-s n))
player-factory.rkt:(define (inf-loop-player n)
player-factory.rkt:  (define (S . x) (if (> n 0) (begin (set! n (- n 1)) (apply ordered-s x)) (let L () (L))))
player-factory.rkt:(define (merge-bad-player) (new merger%))
player-factory.rkt:(define (setup-bad-player) (new setup%))
player-factory.rkt:(define (inform-bad-player) (new inform%))
player-factory.rkt:(define (receive-bad-player) (new receive%))
player-factory.rkt:(define (end-bad-player) (new the-end%))
player-factory.rkt:(define (keep-bad-player) (new keep%))
player-factory.rkt:;; Strategy Nat -> [Listof ExternalPlayer]
player-factory.rkt:  (for/list ((name '("a" "b" "c" "d" "e" "f")) (i (in-range n))) (create name S)))
player-factory.rkt:    (init-field 
player-factory.rkt:     (choice ordered-s))
player-factory.rkt:    (super-new)
player-factory.rkt:    (define/public (go a) (send a sign-up name this))
player-factory.rkt:    (define/public (take-turn turn) (choice turn))
player-factory.rkt:    (define/public (keep acquired-hotels) (map (lambda (x) #t) acquired-hotels))
player-factory.rkt:    (define/public (receive-tile t) (void)) 
player-factory.rkt:    (define/public (inform s) (void)) ;; <---- infinite loop 
player-factory.rkt:    (define/public (the-end s sc) (void))))
player-factory.rkt:    (super-new (name "diverges on set up"))
player-factory.rkt:    (super-new (name "diverges on inform"))
player-factory.rkt:    (super-new (name "diverges on receive"))
player-factory.rkt:    (define/override (receive-tile t) (let L () (L)))))
player-factory.rkt:(define the-end%
player-factory.rkt:    (super-new (name "diverges on end game"))
player-factory.rkt:    (define/override (the-end s c) (let L () (L)))))
player-factory.rkt:    (super-new (name "diverges on keep"))
player-factory.rkt:    (super-new
player-factory.rkt:     (choice (lambda x (if *keep (let L () (L)) (apply ordered-s x)))))
player-intf.rkt:;; ---------------------------------------------------------------------------------------------------
player-intf.rkt:;; see admin-intf for the actual player interface (player/c) 
player-intf.rkt:(require "admin-intf.rkt" "basics.rkt" "board.rkt"  "strategy-intf.rkt" "Lib/contract.rkt")
player-intf.rkt:  [player?  (-> any/c boolean?)]
player-intf.rkt:  [create   (-> string? strategy/c (instanceof/c player/c))])
player-intf.rkt:(interface player-extra&
player-intf.rkt:   (-> strategy/c board? cash? (listof tile?) shares? (listof hotel?)
player-intf.rkt:       (-> board? player/c (-> (maybe/c tile?) (maybe/c hotel?) shares-order/c any))
player-intf.rkt:  ;; --- externalize results of player's turn actions 
player-intf.rkt:   (-> any/c boolean?)]
player-intf.rkt:  [action->xexpr
player-intf.rkt:   (-> (maybe/c tile?) (maybe/c hotel?) shares-order/c xaction?)])
player.rkt:;; ---------------------------------------------------------------------------------------------------
player.rkt:(require "player-intf.rkt")
player.rkt:(player-extra& testx xaction? action->xexpr)
player.rkt:;; ---------------------------------------------------------------------------------------------------
player.rkt:(require #;"admin.rkt" #;"basics.rkt" #;"board.rkt" "strategy.rkt" #;(prefix-in i: "state.rkt") "Lib/xml.rkt")
player.rkt:(require (except-in "typed-wrapper.rkt"
player.rkt:                    state-shares
player.rkt:                    state-sub-shares
player.rkt:                    *create-state
player.rkt:                    *create-player
player.rkt:                    player-name
player.rkt:                    player-shares
player.rkt:                    state-players))
player.rkt:(require (prefix-in i: (only-in "typed-wrapper.rkt"
player.rkt:                                state-shares
player.rkt:                                state-sub-shares
player.rkt:                                *create-state
player.rkt:                                *create-player
player.rkt:                                player-name
player.rkt:                                state-players
player.rkt:                                player-shares)))
player.rkt:  (is-a? x player%))
player.rkt:    (init-field name choice)
player.rkt:    (super-new)
player.rkt:    (define *my-game-name "")
player.rkt:      (set! *my-game-name (send administrator sign-up name this)))
player.rkt:      (bad-players (i:state-players s)))
player.rkt:    (define/public (take-turn turn) 
player.rkt:      (bad-players (get-field players turn))
player.rkt:      (define-values (to-place hotel shares-to-buy) (choice (reconcile turn)))
player.rkt:      (values to-place hotel shares-to-buy))
player.rkt:    (define/public (receive-tile t)
player.rkt:      (bad-players (i:state-players s)))
player.rkt:    (define/public (the-end state results)
player.rkt:    ;; [Listof Players] -> Void
player.rkt:    ;; effect: move the drop-out players to this.*bad, keep the good ones in this.*players
player.rkt:    (define/private (bad-players players)
player.rkt:            (for/fold ((bad *bad)) ((old-player *players)) 
player.rkt:              (define n (i:player-name old-player))
player.rkt:              (if (findf (lambda (current) (string=? (i:player-name current) n)) players) 
player.rkt:                  (cons old-player bad))))
player.rkt:    ;; Turn -> Turn 
player.rkt:    ;; effect: reduce the turn's banker-shares by the shares of this.*bad players 
player.rkt:      (define bad-shares (*combine-shares (map i:player-shares *bad)))
player.rkt:      (send turn reconcile-shares bad-shares)
player.rkt:;; ---------------------------------------------------------------------------------------------------
player.rkt:  (xml-predicate 
player.rkt:   (action ((hotel1 string->hotel)) xplace?)
player.rkt:   (action ((hotel1 string->hotel) (hotel2 string->hotel)) xplace?)
player.rkt:   (action ((hotel1 string->hotel) (hotel2 string->hotel) (hotel3 string->hotel)) xplace?)
player.rkt:   (action ((hotel1 string->hotel)))
player.rkt:   (action ((hotel1 string->hotel) (hotel2 string->hotel)))
player.rkt:   (action ((hotel1 string->hotel) (hotel2 string->hotel) (hotel3 string->hotel)))))
player.rkt:;; Xexpr -> Boolean 
player.rkt:  (xml-predicate 
player.rkt:   (place ((column string->column) (row string->row) (hotel string->hotel)))
player.rkt:   (place ((column string->column) (row string->row)))))
player.rkt:(define (action->xexpr placement hotel shares-to-buy)
player.rkt:  (define attributes (numbered-attributes "hotel~a" hotel->label shares-to-buy))
player.rkt:     (define spot (second (tile->xexpr placement)))
player.rkt:     (define hotl (if hotel `((hotel ,(hotel->label hotel))) '()))
player.rkt:;; ---------------------------------------------------------------------------------------------------
player.rkt:;; Strategy Board Money Tiles Shares [Board Player -> [Tile [Listof Shares] -> Any]] -> Any 
player.rkt:(define (testx S board money tiles available-shares available-hotels checker)
player.rkt:  (define ip (i:*create-player "a" money player-shares0 tiles))
player.rkt:  (call-with-values 
player.rkt:   (lambda () (send p take-turn (create-test-turn board ip available-shares available-hotels)))
player.rkt:(define (create-test-turn board ip available-shares available-hotels)
player.rkt:  (define c0 (i:*create-state board (list ip)))
player.rkt:  (define c1 (i:state-sub-shares c0 (shares-minus banker-shares0 available-shares)))
player.rkt:  (new test-turn% [current-state c1][available-hotels available-hotels]))
player.rkt:(define test-turn%
player.rkt:    (init-field available-hotels)
player.rkt:    (inherit-field current-state shares hotels)
player.rkt:    (super-new)
player.rkt:    (set! hotels available-hotels)
player.rkt:    (define/override (reconcile-shares t)
player.rkt:      (set! current-state (i:state-sub-shares current-state t))
player.rkt:      (set! shares (i:state-shares current-state))
player.rkt:;; ---------------------------------------------------------------------------------------------------
player.rkt:  ;; Strategy Board Cash [Listof Tile] Shares [Listof Hotel] [Maybe Tile] [Maybe Hotel] Shares -> Any 
player.rkt:  (define (test S board0 cash t* available-shares available-hotels e-placement e-hotel e-shares)
player.rkt:      (lambda (placement hotel shares-to-buy)
player.rkt:        (check-equal? hotel e-hotel)
player.rkt:        (define kind (if placement (what-kind-of-spot board0 placement) IMPOSSIBLE))
player.rkt:        (check-true (if (and hotel placement) (cons? (member kind FM)) #t))
player.rkt:        (define next-board 
player.rkt:              (set-board board placement kind hotel)
player.rkt:        (check-equal? placement e-placement)
player.rkt:        (check-equal? shares-to-buy e-shares)))
player.rkt:    (testx S board0 cash t* available-shares available-hotels checker))
player.rkt:  ;; -------------------------------------------------------------------------------------------------
player.rkt:  (define tower-shares (*create-shares TOWER 3))
player.rkt:    (*combine-shares 
player.rkt:      (*create-shares FESTIVAL 1) tower-shares)))
player.rkt:  (define h0 ALL-HOTELS)
player.rkt:  (test ordered-s     b0 CASH0 t0 banker-shares0 h0 A2 #f `(,AMERICAN ,AMERICAN))
player.rkt:  (test largest-alpha b0 CASH0 t0 banker-shares0 h0 A7 #f `(,AMERICAN ,AMERICAN))
player.rkt:  (test smallest-anti b0 CASH0 t0 banker-shares0 h0 A2 #f `(,TOWER ,TOWER))
player.rkt:  (test ordered-s     b0 CASH0 t0 tower-shares h0 A2 #f `(,TOWER ,TOWER))
player.rkt:  (test largest-alpha b0 CASH0 t0 tower-shares h0 A7 #f `(,TOWER ,TOWER))
player.rkt:  (test smallest-anti b0 CASH0 t0 tower-shares h0 A2 #f `(,TOWER ,TOWER))
player.rkt:  (test ordered-s     b0 CASH0 t0 s0 h0 A2 #f `(,FESTIVAL))
player.rkt:  (test largest-alpha b0 CASH0 t0 s0 h0 A7 #f `(,FESTIVAL))
player.rkt:  (test smallest-anti b0 CASH0 t0 s0 h0 A2 #f `(,TOWER ,TOWER))
player.rkt:  (test ordered-s     b0 10 t0 s0 h0 A2 #f '())
player.rkt:  (test largest-alpha b0 10 t0 s0 h0 A7 #f '())
player.rkt:  (test smallest-anti b0 10 t0 s0 h0 A2 #f '())
player.rkt:  ;; -------------------------------------------------------------------------------------------------
player.rkt:  (define b1 (*create-board-with-hotels (list A1) '()))
player.rkt:  (test ordered-s     b1 CASH0 t0 banker-shares0 h0 A2 AMERICAN `(,AMERICAN ,AMERICAN))
player.rkt:  (test largest-alpha b1 CASH0 t0 banker-shares0 h0 A7 #f       `(,AMERICAN ,AMERICAN))
player.rkt:  (test smallest-anti b1 CASH0 t0 banker-shares0 h0 A2 AMERICAN `(,TOWER ,TOWER))
player.rkt:  ;; -------------------------------------------------------------------------------------------------
player.rkt:  (define Sackson-tiles
player.rkt:           (build-list 12 (lambda (i) (ctile F (+ i 1))))
player.rkt:           (build-list 12 (lambda (i) (ctile G (+ i 1))))
player.rkt:           (build-list 12 (lambda (i) (ctile H (+ i 1)))))))
player.rkt:  (define b2 (*create-board-with-hotels (list I12) (list Sackson-tiles)))
player.rkt:  (define price-of-Sackson (price-per-share SACKSON (length Sackson-tiles)))
player.rkt:  (define price-of-Worldwide (price-per-share WORLDWIDE 0))
player.rkt:  (define s2 (*combine-shares (list (*create-shares SACKSON 2) (*create-shares WORLDWIDE 10))))
player.rkt:  (define h2 (remove SACKSON ALL-HOTELS))
player.rkt:  (test ordered-s     b2 CASH0 t0 s2 h2 A2 #f `(,SACKSON ,SACKSON))
player.rkt:  (test largest-alpha b2 CASH0 t0 s2 h2 A7 #f `(,SACKSON ,SACKSON))
player.rkt:  (test smallest-anti b2 CASH0 t0 s2 h2 A2 #f `(,SACKSON ,SACKSON))
player.rkt:  ;; -------------------------------------------------------------------------------------------------
player.rkt:  (define Worldwide-tiles (cons WORLDWIDE (build-list 6 (lambda (i) (ctile D (+ i 1))))))
player.rkt:  (define b3 (*create-board-with-hotels '() (list Worldwide-tiles Sackson-tiles)))
player.rkt:  (test ordered-s     b3 CASH0 t3 s2 h3 #f #f `(,SACKSON ,SACKSON))
player.rkt:  (test largest-alpha b3 CASH0 t3 s2 h3 #f #f `(,SACKSON ,SACKSON))
player.rkt:  (test smallest-anti b3 CASH0 t3 s2 h3 #f #f `(,WORLDWIDE ,WORLDWIDE))
player.rkt:  ;; -------------------------------------------------------------------------------------------------
player.rkt:  (define Tower-tiles (cons TOWER (list F1 F2)))
player.rkt:  (define b4 (*create-board-with-hotels '() (list Worldwide-tiles Tower-tiles)))
player.rkt:  (define h4 (remove* `(,WORLDWIDE ,TOWER) ALL-HOTELS))
player.rkt:  (test ordered-s     b4 CASH0 t3 s2 h4 E1 WORLDWIDE `(,WORLDWIDE ,WORLDWIDE))
player.rkt:  (test largest-alpha b4 CASH0 t3 s2 h4 E6 #f        `(,WORLDWIDE ,WORLDWIDE))
player.rkt:  (test smallest-anti b4 CASH0 t3 s2 h4 E1 WORLDWIDE `(,WORLDWIDE ,WORLDWIDE))
player.rkt:  (define American-tiles (cons AMERICAN (list E3 E4)))
player.rkt:  (define Continental-tiles (cons CONTINENTAL (list D1 D2)))
player.rkt:  (define b5 (*create-board-with-hotels '() (list American-tiles Continental-tiles Tower-tiles)))
player.rkt:  (define h5 (remove* `(,AMERICAN ,CONTINENTAL ,TOWER) ALL-HOTELS))
player.rkt:  (test ordered-s     b5 CASH0 (list E2) s2 h5 E2 AMERICAN '())
player.rkt:  (test largest-alpha b5 CASH0 (list E2) s2 h5 E2 AMERICAN '())
player.rkt:  (test smallest-anti b5 CASH0 (list E2) s2 h5 E2 AMERICAN '())
player.rkt:  ;; -------------------------------------------------------------------------------------------------
player.rkt:  (define b7 (*create-board-with-hotels '() (list American-tiles)))
player.rkt:  (define t7 (cons B7 (rest (build-list 6 (lambda (i) (ctile A (+ i 1)))))))
player.rkt:  (test ordered-s     b7 CASH0 t7 banker-shares0 ALL-HOTELS A2 #f `(,AMERICAN ,AMERICAN))
player.rkt:  (test largest-alpha b7 CASH0 t7 banker-shares0 ALL-HOTELS B7 #f `(,AMERICAN ,AMERICAN))
player.rkt:  (test smallest-anti b7 CASH0 t7 banker-shares0 ALL-HOTELS A2 #f `(,TOWER ,TOWER))
player.rkt:  (define b8 (*create-board-with-hotels '() (list Continental-tiles)))
player.rkt:  (define h8 (remove CONTINENTAL ALL-HOTELS))
player.rkt:  (test ordered-s     b8 400 t8 (*create-shares CONTINENTAL 1) h8 D3 #f '())
player.rkt:  (test largest-alpha b8 400 t8 (*create-shares CONTINENTAL 1) h8 D3 #f '())
player.rkt:  (test smallest-anti b8 400 t8 (*create-shares CONTINENTAL 1) h8 D3 #f '())
player.rkt:  (define b9 (*create-board-with-hotels (list A1) '()))
player.rkt:  (test ordered-s     b9 300 t9 (*create-shares AMERICAN 1) `(,AMERICAN) A2 AMERICAN '())  
player.rkt:  (test largest-alpha b9 300 t9 (*create-shares AMERICAN 1) `(,AMERICAN) A2 AMERICAN '())  
player.rkt:  (test smallest-anti b9 300 t9 (*create-shares AMERICAN 1) `(,AMERICAN) A2 AMERICAN '())  
player.rkt:  ;; --- testing bad player management 
player.rkt:  (define-syntax-rule 
player.rkt:    (test-reconcile p pa pb snd ... ordered-s)
player.rkt:      (define pb (i:*create-player "b" CASH0 (shares++ player-shares0 AMERICAN) (list A1)))
player.rkt:      (define pa (i:*create-player "a" CASH0 (shares++ player-shares0 AMERICAN) '()))
player.rkt:      (define p (create "b" ordered-s))
player.rkt:      (define t (create-test-turn (board) pb (shares++ player-shares0 AMERICAN) '()))
player.rkt:      (define-values (_t _h o) (send p take-turn t))
player.rkt:      (check-equal? o '() "cannot buy stock because bad guy owns it")))  
player.rkt:  (test-reconcile p pa pb (send p setup (i:state0 pb pa)) (send p inform (i:state0 pb)) ordered-s)
player.rkt:  (test-reconcile p pa pb (send p setup (i:state0 pb pa)) ordered-s)
player.rkt:  (test-reconcile p pa pb (send p inform (i:state0 pb pa)) ordered-s)
player.rkt:  (test-reconcile p pa pb (send p setup (i:state0 pb pa)) (send p inform (i:state0 pb)) random-s)
player.rkt:  (test-reconcile p pa pb (send p setup (i:state0 pb pa)) random-s)
player.rkt:  (test-reconcile p pa pb (send p inform (i:state0 pb pa)) random-s)
protocols.rkt:;; ---------------------------------------------------------------------------------------------------
protocols.rkt: (contract-out
protocols.rkt:  [turn-player/c 
protocols.rkt:  [board-well-formed
protocols.rkt:   (-> board? any)]
protocols.rkt:  [complementary-hotels 
protocols.rkt:   (-> board? (-> (listof hotel?) any))]
protocols.rkt:  [good-placement 
protocols.rkt:   (-> (instanceof/c turn-player/c) (-> (maybe/c tile?) any))]
protocols.rkt:  [good-hotel-for-placement 
protocols.rkt:   (-> (instanceof/c turn-player/c) (maybe/c tile?) (-> (maybe/c hotel?) any))]
protocols.rkt:  [good-shares 
protocols.rkt:   (-> (instanceof/c turn-player/c) (maybe/c tile?) (maybe/c hotel?) (-> shares-order/c any))]))
protocols.rkt:   see admin-intf for player signatures
protocols.rkt:              |------------------------------> t = Turn     |        |        |  internal state 
protocols.rkt:              |-------------------------------------------->|        |        |  initiate turn 
protocols.rkt:              |                                |<-----------|        |        |  a merger placement
protocols.rkt:              |                                |----------->|        |        |  any shares in the
protocols.rkt:              |                                |-------------------->|        |
protocols.rkt:              |                                |----------------------------->|
protocols.rkt:              |                               ---           |        |        |
protocols.rkt:              |                              -----          |        |        |  if okay, commit 
protocols.rkt:(define turn-player/c
protocols.rkt:   (init-field 
protocols.rkt:    (current-state state?))
protocols.rkt:    ;; (board-well-formed b)
protocols.rkt:    ;; (complementary-hotels board)
protocols.rkt:   (reconcile-shares 
protocols.rkt:    (->m shares? any))
protocols.rkt:    (->dm ([t tile?][h hotel?]) #:pre (eq? (what-kind-of-spot (get-field board this) t) MERGING)
protocols.rkt:;; --- turn input 
protocols.rkt:(define (board-well-formed b)
protocols.rkt:(define (complementary-hotels b)
protocols.rkt:  (define founded-hotels (filter (lambda (h) (size-of-hotel b h)) ALL-HOTELS))
protocols.rkt:  (define ALL-HOTELS-set (apply seteq ALL-HOTELS))
protocols.rkt:    (set=? (apply seteq (append founded-hotels lh)) ALL-HOTELS-set)))
protocols.rkt:;; --- turn output 
protocols.rkt:(define (good-placement turn)
protocols.rkt:  (define board (get-field board turn))
protocols.rkt:  (define players-tiles (player-tiles (get-field current turn)))
protocols.rkt:        (and (member t players-tiles)
protocols.rkt:             (not (eq? (what-kind-of-spot board t) IMPOSSIBLE))))))
protocols.rkt:(define (good-hotel-for-placement turn placement)
protocols.rkt:  (define board (get-field board turn))
protocols.rkt:  (define available-h (get-field hotels turn))
protocols.rkt:       (define s (what-kind-of-spot board t))
protocols.rkt:       (and (memq s (list FOUNDING SINGLETON GROWING)) (==> (eq? s FOUNDING) (empty? available-h)))]
protocols.rkt:       (define s (what-kind-of-spot board t))
protocols.rkt:         [(eq? FOUNDING s) (==> (cons? available-h) (member h available-h))]
protocols.rkt:         [(eq? MERGING s) (let-values ([(w _) (merging-which board t)]) (member h w))]
protocols.rkt:(define (good-shares turn tile hotel)
protocols.rkt:       (let ((state (get-field current-state turn)))
protocols.rkt:           ;; did turn use a side-effect to update the state?, if not:
protocols.rkt:           [(free-spot? (state-board state) tile)
protocols.rkt:                (state-place-tile state tile hotel)
protocols.rkt:                (state-place-tile state tile))]
protocols.rkt:     (define board (state-board state))
protocols.rkt:     (define player-s-cash (player-money (state-current-player state)))
protocols.rkt:     (define available-s (state-shares state))
protocols.rkt:     (define (l-affordable? hotels) (affordable? board hotels player-s-cash))
protocols.rkt:     (define (l-available? hotels) (shares-available? available-s hotels))
protocols.rkt:     (and/c l-available? l-affordable?)]))
remote-actor-intf.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor-intf.rkt:(require "basics.rkt" "board.rkt" "protocols.rkt" "state-intf.rkt" "state.rkt" "Lib/contract.rkt" xml)
remote-actor-intf.rkt:(define (parser/c p) (-> any/c (maybe/c p)))
remote-actor-intf.rkt:(define-syntax-rule (writer/c d ...) (-> d ... xexpr?))
remote-actor-intf.rkt:(interface remote-connectivity&
remote-actor-intf.rkt:  ;; (class/remote class-clause ...)
remote-actor-intf.rkt:  ;; create class extension of remote-actor% that 
remote-actor-intf.rkt:  ;; -- inherits three methods: xsend, xreceive, okay
remote-actor-intf.rkt:  ;; -- inherits three fields: name, in, out 
remote-actor-intf.rkt:  ;; -- sets up an exn macro for dealing with exns in handlers
remote-actor-intf.rkt:  (signup-parser (parser/c string?))
remote-actor-intf.rkt:  (signup-writer (writer/c string?))
remote-actor-intf.rkt:  (void-parser (parser/c any/c))
remote-actor-intf.rkt:  (void-writer (writer/c))
remote-actor-intf.rkt:  (tile-parser (parser/c tile?))
remote-actor-intf.rkt:  (tile-writer (writer/c tile?))
remote-actor-intf.rkt:  (turn-parser (parser/c state?))
remote-actor-intf.rkt:  (turn-writer (writer/c (instanceof/c turn-player/c)))
remote-actor-intf.rkt:  (state-parser (parser/c state?))
remote-actor-intf.rkt:  (state-writer (writer/c state?))
remote-actor-intf.rkt:  (turn-plain-parser (parser/c (list/c tile? (maybe/c hotel?) shares-order/c)))
remote-actor-intf.rkt:  (turn-plain-writer (writer/c tile? (maybe/c hotel?) shares-order/c))
remote-actor-intf.rkt:  (turn-merge-parser (parser/c (list/c tile? (maybe/c hotel?))))
remote-actor-intf.rkt:  (turn-merge-writer (writer/c tile? (maybe/c hotel?)))
remote-actor-intf.rkt:  (placement-parser (parser/c (list/c tile? (maybe/c hotel?))))
remote-actor-intf.rkt:  (placement-writer (writer/c tile? (maybe/c hotel?)))
remote-actor-intf.rkt:  (order-parser (parser/c shares-order/c))
remote-actor-intf.rkt:  (order-writer (writer/c shares-order/c))
remote-actor-intf.rkt:  (keeps-parser (parser/c (listof hotel?)))
remote-actor-intf.rkt:  (keeps-writer (writer/c (listof hotel?)))
remote-actor-intf.rkt:  (booleans-parser (parser/c (listof boolean?)))
remote-actor-intf.rkt:  (booleans-writer (writer/c (listof boolean?)))
remote-actor-intf.rkt:  (players-parser (parser/c (listof player?)))
remote-actor-intf.rkt:  (players-writer (writer/c (listof player?)))
remote-actor-intf.rkt:  (end-parser (parser/c (cons/c state? score/c)))
remote-actor-intf.rkt:  (end-writer (writer/c score/c state?)))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(require "remote-actor-intf.rkt")
remote-actor.rkt:(remote-connectivity&
remote-actor.rkt:  signup-parser signup-writer void-parser void-writer tile-parser tile-writer  
remote-actor.rkt:  turn-parser turn-writer state-parser state-writer turn-plain-parser turn-plain-writer
remote-actor.rkt:  turn-merge-parser turn-merge-writer placement-parser placement-writer order-parser order-writer 
remote-actor.rkt:  keeps-parser keeps-writer booleans-parser booleans-writer players-parser players-writer
remote-actor.rkt:  end-parser end-writer)
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:         (except-in "basics.rkt" hotel? shares-order? cash?) 
remote-actor.rkt:         (except-in "board.rkt" tile? board? xtile? tile->xexpr) 
remote-actor.rkt:         (except-in "state.rkt" state? player? xstate? state->xexpr) 
remote-actor.rkt:               [tile->xexpr (Tile -> XTile)])
remote-actor.rkt:               [state->xexpr (State -> XState)])
remote-actor.rkt:               [#:opaque Shares-Order shares-order?]
remote-actor.rkt:(define-type (Parser p) (Any -> (Option p)))
remote-actor.rkt:(define-type Score (Listof (List String Cash)))
remote-actor.rkt:  (require rackunit (submod "board.rkt" tiles+spots) (submod "state.rkt" sample-states)))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(: signup-parser (Parser String))
remote-actor.rkt:(define signup-parser 
remote-actor.rkt:  (xml-parser (signup ((name values)) #:action name)))
remote-actor.rkt:(define (signup-writer name)
remote-actor.rkt:  (check-equal? (signup-parser (signup-writer "Hello")) "Hello"))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(: void-parser (Parser Any))
remote-actor.rkt:(define void-parser
remote-actor.rkt:  (xml-parser (void () #:action (void))))
remote-actor.rkt:(define (void-writer)
remote-actor.rkt:  (check-equal? (void-parser (void-writer)) (void)))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(: tile-writer (Tile -> XTile))
remote-actor.rkt:(define (tile-writer t)
remote-actor.rkt:  (tile->xexpr t))
remote-actor.rkt:(: tile-parser (Parser Tile))
remote-actor.rkt:(define tile-parser 
remote-actor.rkt:  (xml-parser (tile ((column string->column) (row string->row)) #:action (tile column row))))
remote-actor.rkt:  (check-equal? (tile-parser (tile-writer H11)) H11))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(define (turn-writer t)
remote-actor.rkt:  (define s (state->xexpr (get-field current-state t)))
remote-actor.rkt:(: turn-parser (Parser State))
remote-actor.rkt:(define turn-parser
remote-actor.rkt:  (xml-parser
remote-actor.rkt:   (turn () (b board-parser) (p player-parser) ... #:action (*create-state b p))))
remote-actor.rkt:  (define t0 (new turn% [current-state s0]))
remote-actor.rkt:  (check-equal? (turn-parser (turn-writer t0)) s0)
remote-actor.rkt:  (define t1 (new turn% [current-state s1]))
remote-actor.rkt:  (check-equal? (turn-parser (turn-writer t1)) s1))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(define (state-writer s)
remote-actor.rkt:  (state->xexpr s))
remote-actor.rkt:(: state-parser (Parser State))
remote-actor.rkt:(define state-parser 
remote-actor.rkt:  (xml-parser (state () (b board-parser) (p player-parser) ... #:action (*create-state b p))))
remote-actor.rkt:(: board-parser (Parser Board))
remote-actor.rkt:(define board-parser
remote-actor.rkt:  (xml-parser
remote-actor.rkt:   (board () (t tile-parser) ... (h boardhotel-parser) ... #:action (*create-board-with-hotels t h))))
remote-actor.rkt:(: player-parser (Parser Player))
remote-actor.rkt:(define player-parser
remote-actor.rkt:  (xml-parser
remote-actor.rkt:   (player ((name values) (cash string->cash)) (s share-p) ... (t tile-parser) ...
remote-actor.rkt:           #:action (*create-player name cash (*combine-shares s) t))))
remote-actor.rkt:(: boardhotel-parser (Parser Hotel))
remote-actor.rkt:(define boardhotel-parser 
remote-actor.rkt:  (xml-parser
remote-actor.rkt:   (hotel ((name string->hotel)) (t1 tile-parser) (t2 tile-parser) (t tile-parser) ... 
remote-actor.rkt:(: share-p (Parser Any))
remote-actor.rkt:(define share-p
remote-actor.rkt:  (xml-parser
remote-actor.rkt:   (share ((name string->hotel) (count string->count)) #:action (*create-shares name count))))
remote-actor.rkt:  (define a-player (first (state-players s0)))
remote-actor.rkt:  (check-equal? (player-parser (player->xexpr a-player)) a-player)
remote-actor.rkt:  (define a-board (state-board s0))
remote-actor.rkt:  (check-equal? (board-parser (board->xexpr a-board)) a-board)
remote-actor.rkt:  (check-equal? (state-parser (state-writer s0)) s0)
remote-actor.rkt:  (check-equal? (state-parser (state-writer s1)) s1))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(define (turn-plain-writer t h o)
remote-actor.rkt:  `(pbuy () ,(placement-writer t h) ,(order-writer o)))
remote-actor.rkt:(define turn-plain-parser 
remote-actor.rkt:  (xml-parser
remote-actor.rkt:   (pbuy () (placement placement-parser) (order order-parser) #:action (append placement `(,order)))))
remote-actor.rkt:(define (turn-merge-writer t h)
remote-actor.rkt:  (placement-writer t h))
remote-actor.rkt:(define (turn-merge-parser x) 
remote-actor.rkt:  (define r (placement-parser x))
remote-actor.rkt:  (unless (or (boolean? r) (second r)) (error 'turn-merge-parser "bad merge response: ~e" x))
remote-actor.rkt:(define (placement-writer t h)
remote-actor.rkt:      `(placement () ,(tile->xexpr t) ,(xhotel-writer h))
remote-actor.rkt:      `(placement () ,(tile->xexpr t))))
remote-actor.rkt:(define placement-parser
remote-actor.rkt:  (xml-parser 
remote-actor.rkt:   (placement () (tile tile-parser) #:action (list tile #f))
remote-actor.rkt:   (placement () (tile tile-parser) (hotel xhotel-parser) #:action (list tile hotel))))
remote-actor.rkt:(define (order-writer loh)
remote-actor.rkt:  `(order () ,@(map xhotel-writer loh)))
remote-actor.rkt:(: order-parser (Parser Shares-Order))
remote-actor.rkt:(define order-parser
remote-actor.rkt:  (xml-parser (order () (xhotel xhotel-parser) ... 
remote-actor.rkt:                     (if (<= (length xhotel) SHARES-PER-TURN#)
remote-actor.rkt:                         (error 'order-parser "FIX: mistake in protocol specification")))))
remote-actor.rkt:(define (xhotel-writer h)
remote-actor.rkt:  (hotel->xexpr h))
remote-actor.rkt:(: xhotel-parser (Parser Any))
remote-actor.rkt:(define xhotel-parser
remote-actor.rkt:  (xml-parser (hotel ((label string->hotel)) #:action label)))
remote-actor.rkt:  (check-equal? (xhotel-parser (xhotel-writer AMERICAN)) AMERICAN)
remote-actor.rkt:  (check-equal? (order-parser (order-writer `())) `())
remote-actor.rkt:  (check-equal? (order-parser (order-writer `(,AMERICAN))) `(,AMERICAN))
remote-actor.rkt:  (check-equal? (order-parser (order-writer `(,AMERICAN ,TOWER))) `(,AMERICAN ,TOWER))
remote-actor.rkt:  (check-equal? (placement-parser (placement-writer I12 FESTIVAL)) `(,I12 ,FESTIVAL))
remote-actor.rkt:  (check-equal? (placement-parser (placement-writer I12 #f)) `(,I12 #f))
remote-actor.rkt:  (check-equal? (turn-plain-parser (turn-plain-writer B3 #f `(,TOWER))) `(,B3 ,#f (,TOWER)))
remote-actor.rkt:  (check-false (turn-plain-parser (turn-merge-writer B3 TOWER)))
remote-actor.rkt:  (check-equal? (turn-merge-parser (turn-merge-writer B3 TOWER)) `(,B3 ,TOWER)))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(define (keeps-writer loh)
remote-actor.rkt:  `(keep () ,@(map xhotel-writer loh)))
remote-actor.rkt:(: keeps-parser (Parser Any))
remote-actor.rkt:(define keeps-parser 
remote-actor.rkt:  (xml-parser (keep () (xhotel xhotel-parser) ... 
remote-actor.rkt:                    (if (<= 1 (length xhotel) 3) ;; <--- MAGIC: max number of hotels acquired
remote-actor.rkt:  (check-equal? (keeps-parser (keeps-writer `(,AMERICAN))) `(,AMERICAN))
remote-actor.rkt:  (check-equal? (keeps-parser (keeps-writer `(,AMERICAN ,TOWER))) `(,AMERICAN ,TOWER))
remote-actor.rkt:  (check-equal?
remote-actor.rkt:   (keeps-parser (keeps-writer `(,AMERICAN ,FESTIVAL ,TOWER))) `(,AMERICAN ,FESTIVAL ,TOWER)))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(define (booleans-writer lob)
remote-actor.rkt:  `(keep () ,@(map boolean-writer lob)))
remote-actor.rkt:(: booleans-parser (Parser (Listof Boolean)))
remote-actor.rkt:(define booleans-parser 
remote-actor.rkt:  (xml-parser (keep () (b boolean-parser) ... #:action (map (lambda (x) (if (symbol? x) #f #t)) b))))
remote-actor.rkt:(define (boolean-writer b)
remote-actor.rkt:(define boolean-parser
remote-actor.rkt:  (xml-parser 
remote-actor.rkt:   (true () #:action #t) ;; parsing false as #f would fail in booleans-parser
remote-actor.rkt:  (check-equal? (booleans-parser (booleans-writer '(#t #t #f))) '(#t #t #f)))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(define (players-writer lop)
remote-actor.rkt:  `(players () ,@(map player->xexpr lop)))
remote-actor.rkt:(: players-parser (Parser (Listof Player)))
remote-actor.rkt:(define players-parser
remote-actor.rkt:  (xml-parser (players () (p player-parser) ... #:action p)))
remote-actor.rkt:  (define p0 (state-players s0))
remote-actor.rkt:  (check-equal? (players-parser (players-writer p0)) p0)
remote-actor.rkt:  (define p1 (state-players s1))
remote-actor.rkt:  (check-equal? (players-parser (players-writer p1)) p1))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:(define (end-writer sc st)
remote-actor.rkt:  `(score () ,@(map result-writer sc) ,(state-writer st)))
remote-actor.rkt:(: end-parser (Parser (Pairof State Score)))
remote-actor.rkt:(define end-parser 
remote-actor.rkt:  (xml-parser 
remote-actor.rkt:   (score () (result result-parser) ... (state state-parser) #:action (cons state result))))
remote-actor.rkt:(define (result-writer r)
remote-actor.rkt:  `(result ((name ,(first r)) (score ,(cash->string (second r))))))
remote-actor.rkt:(: result-parser (Parser Any))
remote-actor.rkt:(define result-parser
remote-actor.rkt:  (xml-parser (result ((name values) (score string->cash)) #:action (list name score))))
remote-actor.rkt:  (check-equal? (result-parser (result-writer (list "Hello" 100))) (list "Hello" 100))
remote-actor.rkt:  (check-equal? (end-parser (end-writer sc s0)) (cons s0 sc))
remote-actor.rkt:  (check-equal? (end-parser (end-writer sc s1)) (cons s1 sc)))
remote-actor.rkt:(define-syntax (class/remote stx)
remote-actor.rkt:  (syntax-case stx ()
remote-actor.rkt:     (let ((xsend (datum->syntax stx 'xsend))
remote-actor.rkt:           (xreceive (datum->syntax stx 'xreceive))
remote-actor.rkt:           (okay (datum->syntax stx 'okay))
remote-actor.rkt:           (name (datum->syntax stx 'name))
remote-actor.rkt:           (in (datum->syntax stx 'in))
remote-actor.rkt:           (out (datum->syntax stx 'out))
remote-actor.rkt:           (handle (datum->syntax stx 'handle)))
remote-actor.rkt:       #`(class remote-actor% 
remote-actor.rkt:           (inherit-field #,name #,in #,out)
remote-actor.rkt:           (make-handle #,handle #,in #,out #,name)
remote-actor.rkt:           (super-new)
remote-actor.rkt:(define-syntax-rule 
remote-actor.rkt:  (make-handle handle in out name)
remote-actor.rkt:  (define-syntax-rule 
remote-actor.rkt:    (with-handlers ((exn:fail:network? 
remote-actor.rkt:                       (close-input-port in)
remote-actor.rkt:                       (close-output-port out)
remote-actor.rkt:                       (close-input-port in)
remote-actor.rkt:                       (close-output-port out)
remote-actor.rkt:(define remote-actor% 
remote-actor.rkt:    (init-field in out)
remote-actor.rkt:    (super-new)
remote-actor.rkt:      (write-xml-to x out))
remote-actor.rkt:      (read-xml-from in))
remote-actor.rkt:;; ---------------------------------------------------------------------------------------------------
remote-actor.rkt:  (define remote-service%
remote-actor.rkt:  (define sin (open-input-string "<bye />"))
remote-actor.rkt:  (define sout (open-output-string))
remote-actor.rkt:  (define x (send (new remote-service% [in sin][out sout]) hello))
remote-actor.rkt:  (check-equal? (get-output-string sout) "\n<hello>\n</hello>\n")
remote-actor.rkt:  (check-equal? x '(bye ())))
remote-admin.rkt:;; ---------------------------------------------------------------------------------------------------
remote-admin.rkt:;; -- implement interface of administrator and player turn, respectively
remote-admin.rkt:;; -- communicates with remote proxy player on server side to implement admin/turn functionality 
remote-admin.rkt:(require "admin-intf.rkt") 
remote-admin.rkt:(admin& remote-administrator% remote-turn% DONE EXHAUSTED SCORE)
remote-admin.rkt:;; ---------------------------------------------------------------------------------------------------
remote-admin.rkt:(require (only-in "admin.rkt" DONE EXHAUSTED SCORE) "remote-actor.rkt" "state.rkt" "Lib/io.rkt")
remote-admin.rkt:           "admin.rkt" "state.rkt" (only-in "player.rkt" create) "strategy.rkt"
remote-admin.rkt:           (submod "state.rkt" sample-states) (submod "board.rkt" tiles+spots)))
remote-admin.rkt:;; for the interaction diagram, see protocols.rkt -- the below are remote
remote-admin.rkt:;; proxies that simulate full-fledged administrators and turns on the
remote-admin.rkt:(define remote-administrator%
remote-admin.rkt:   (init-field (next-tile void))
remote-admin.rkt:   (define/public (sign-up local-name player)
remote-admin.rkt:             (xsend (signup-writer local-name))
remote-admin.rkt:             (set! name (signup-parser (xreceive)))
remote-admin.rkt:             (if (boolean? name) (error 'sign-up "server assigned bad name") name)))
remote-admin.rkt:   (define/public (show-players)
remote-admin.rkt:             (send *player setup (okay 'setup-step (state-parser (xreceive))))
remote-admin.rkt:             (xsend (void-writer))
remote-admin.rkt:                 [(keeps-parser msg)
remote-admin.rkt:                  => (lambda (keeps-msg) 
remote-admin.rkt:                       (xsend (booleans-writer (send *player keep keeps-msg)))
remote-admin.rkt:                 [(turn-parser msg)
remote-admin.rkt:                  => (lambda (turn-msg)
remote-admin.rkt:                         (new remote-turn% [in in][out out][current-state turn-msg][player *player]))
remote-admin.rkt:                       (define-values (t h o) (send *player take-turn turn))
remote-admin.rkt:                       (if (send turn place-called)
remote-admin.rkt:                           (xsend (order-writer o))
remote-admin.rkt:                           (xsend (turn-plain-writer t h o)))
remote-admin.rkt:                       ;; end of turn -- common to both 
remote-admin.rkt:                       (send *player receive-tile (okay 'receive-tile (tile-parser (xreceive))))
remote-admin.rkt:                       (xsend (void-writer))
remote-admin.rkt:                 [(state-parser msg)
remote-admin.rkt:                  => (lambda (inform-msg)
remote-admin.rkt:                       (send *player inform inform-msg)
remote-admin.rkt:                       (xsend (void-writer))
remote-admin.rkt:                 [(end-parser msg) 
remote-admin.rkt:                       (xsend (void-writer))
remote-admin.rkt:(define remote-turn-administrator/c
remote-admin.rkt:   ;; ------------------------------------------------------------------------------------------------
remote-admin.rkt:   (place-called
remote-admin.rkt:    (->m boolean?))))
remote-admin.rkt:(define/contract remote-turn%
remote-admin.rkt:  remote-turn-administrator/c
remote-admin.rkt:   (init-field current-state player)
remote-admin.rkt:    [board   (state-board current-state)]
remote-admin.rkt:    [current (state-current-player current-state)]
remote-admin.rkt:    [cash    (player-money current)]
remote-admin.rkt:    [tiles   (player-tiles current)]
remote-admin.rkt:    [shares  (state-shares current-state)]
remote-admin.rkt:    [hotels  (state-hotels current-state)]
remote-admin.rkt:    [players (state-players current-state)])
remote-admin.rkt:   ;; -----------------------------------------------------------------------------------------------
remote-admin.rkt:   (define/public (reconcile-shares bad-shares)
remote-admin.rkt:             (set! current-state (state-sub-shares current-state bad-shares))
remote-admin.rkt:             (set! shares (state-shares current-state))))
remote-admin.rkt:   (define/public (place-called)
remote-admin.rkt:             (xsend (turn-merge-writer t h))
remote-admin.rkt:             (xsend (booleans-writer (send player keep (okay 'keep-in-turn (keeps-parser (xreceive))))))
remote-admin.rkt:             (okay 'place (players-parser (xreceive)))))))
remote-admin.rkt:;; ---------------------------------------------------------------------------------------------------
remote-admin.rkt:  ;; String ->* Admin IPort OPort RemotePlayer 
remote-admin.rkt:  (define (create-bundle s)
remote-admin.rkt:    (define p0 (create "hello" ordered-s))
remote-admin.rkt:    (define i0 (open-input-string s))
remote-admin.rkt:    (define o0 (open-output-string))
remote-admin.rkt:    (define r0 (new remote-administrator% [in i0][out o0]))
remote-admin.rkt:  (define-syntax-rule 
remote-admin.rkt:           (let loop ((op2 (open-input-string (get-output-string op))))
remote-admin.rkt:             (define next (read-xml-from op2))
remote-admin.rkt:             (if (eof-object? next) '() (cons next (loop op2))))))
remote-admin.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-admin.rkt:  (define-values (p0 i0 o0 r0) (create-bundle "<signup name=\"spieker11:hello\" />"))
remote-admin.rkt:  (check-equal? (send p0 go r0) (void))
remote-admin.rkt:  (define-values (p1 i1 o1 r1) 
remote-admin.rkt:    (create-bundle 
remote-admin.rkt:     (with-output-to-string
remote-admin.rkt:        ;; --- sign up 
remote-admin.rkt:        (write-xml-to (signup-writer name))
remote-admin.rkt:        ;; --- set up 
remote-admin.rkt:        (define s0 (s0-name name)) ;; player owns a single tile here: A1
remote-admin.rkt:        (write-xml-to (state-writer s0))
remote-admin.rkt:        (define t (new turn% (current-state s0)))
remote-admin.rkt:        ;; --- turn 1 
remote-admin.rkt:        (write-xml-to (turn-writer t))
remote-admin.rkt:        (write-xml-to (tile-writer D7))
remote-admin.rkt:        (define s0+A1 (state-place-tile s0 A1))
remote-admin.rkt:        (write-xml-to (state-writer s0))
remote-admin.rkt:        ;;; --- end 
remote-admin.rkt:        (write-xml-to (end-writer (state-score s0+A1) s0+A1))))))
remote-admin.rkt:  ; (read-xml-from i1)
remote-admin.rkt:              (error 'parse "bad fit: ~a vs ~a" (object-name (first parsers)) (first e))))))
remote-admin.rkt:         signup-parser 
remote-admin.rkt:         void-parser 
remote-admin.rkt:         turn-plain-parser 
remote-admin.rkt:         void-parser 
remote-admin.rkt:         void-parser
remote-admin.rkt:         void-parser))
remote-game.rkt:exec racket -tm "$0" ${1+"$@"}
remote-game.rkt:;; ---------------------------------------------------------------------------------------------------
remote-game.rkt: ;; $ ./remote-game n
remote-game.rkt: (rename-out (run main)))
remote-game.rkt:;; ---------------------------------------------------------------------------------------------------
remote-game.rkt:(require "server-start.rkt" "player-factory.rkt" "remote-admin.rkt")
remote-game.rkt:;; Nat -> Void 
remote-game.rkt:;; run n rounds of random players with one ordered one and then some games with ill-behaving players
remote-game.rkt:  (define n (string->number n:string))
remote-game.rkt:  (define c (make-custodian))
remote-game.rkt:  (parameterize ((current-custodian c))
remote-game.rkt:    (for ((i (in-range n)))
remote-game.rkt:      (go (first (random-players 1))))
remote-game.rkt:      (go (merge-bad-player))
remote-game.rkt:      (go (keep-bad-player))
remote-game.rkt:      (go (end-bad-player))
remote-game.rkt:      (go (receive-bad-player))
remote-game.rkt:      (go (inform-bad-player))
remote-game.rkt:      (go (setup-bad-player))
remote-game.rkt:      (go (inf-loop-player 1))))
remote-game.rkt:  (custodian-shutdown-all c))
remote-game.rkt:  (define c (make-custodian))
remote-game.rkt:  (define all-threads
remote-game.rkt:    (parameterize ((current-custodian c))
remote-game.rkt:      (for/list ((p (cons extra (random-players 3))))
remote-game.rkt:           (define-values (status score _state) (make-player HOST PORT p))
remote-game.rkt:  (let wait ((l all-threads))
remote-game.rkt:  (custodian-shutdown-all c))
remote-game.rkt:(define (make-player host port player)
remote-game.rkt:  (define-values (in out) (tcp-connect host (string->number port)))
remote-game.rkt:  (define remote-administrator (new remote-administrator% [in in][out out]))
remote-game.rkt:  (send player go remote-administrator)
remote-game.rkt:  (send remote-administrator run 0))
remote-player.rkt:;; ---------------------------------------------------------------------------------------------------
remote-player.rkt:;; -- communicates with remote-admin on client side to implement player functionality 
remote-player.rkt:(require "admin-intf.rkt")
remote-player.rkt: (contract-out
remote-player.rkt:  (remote-player% player/c)))
remote-player.rkt:;; ---------------------------------------------------------------------------------------------------
remote-player.rkt:(require "remote-actor.rkt" "Lib/io.rkt")
remote-player.rkt:           (submod "state.rkt" sample-states) (submod "board.rkt" tiles+spots)))
remote-player.rkt:;; for the interaction diagram, see protocols.rkt -- the below is a remote
remote-player.rkt:;; proxy that simulates a full-fledged player on the server computer so
remote-player.rkt:(define remote-player%
remote-player.rkt:     (with-handlers ((exn:fail:network? (lambda (x) (log x `(remote sign up failed ,name)))))
remote-player.rkt:       (set! name (send a sign-up (okay 'go (signup-parser (xreceive))) this))
remote-player.rkt:       (xsend (signup-writer name))))
remote-player.rkt:             (xsend (state-writer s))
remote-player.rkt:             (okay 'setup (void-parser (xreceive)))))
remote-player.rkt:   (define/public (take-turn t)
remote-player.rkt:             (xsend (turn-writer t))
remote-player.rkt:             (define plain-turn (turn-plain-parser response))
remote-player.rkt:               [plain-turn (apply values plain-turn)]
remote-player.rkt:                (define action (turn-merge-parser response))
remote-player.rkt:                (xsend (players-writer (send t place tile hotel)))
remote-player.rkt:                (values tile hotel (okay 'take-turn-order (order-parser (xreceive))))])))
remote-player.rkt:             (xsend (keeps-writer loh))
remote-player.rkt:             (okay 'keep (booleans-parser (xreceive)))))
remote-player.rkt:   (define/public (receive-tile t)
remote-player.rkt:             (xsend (tile-writer t))
remote-player.rkt:             (okay 'receive-tile (void-parser (xreceive)))))
remote-player.rkt:             (xsend (state-writer s))
remote-player.rkt:             (okay 'inform (void-parser (xreceive)))))
remote-player.rkt:   (define/public (the-end st sc)
remote-player.rkt:             (xsend (end-writer sc st))
remote-player.rkt:             (okay 'the-end (void-parser (xreceive)))))))
remote-player.rkt:  ;; String ->* Admin IPort OPort RemotePlayer 
remote-player.rkt:  (define (create-bundle s)
remote-player.rkt:    (define a0 (new administrator% [next-tile first]))
remote-player.rkt:    (define i0 (open-input-string s))
remote-player.rkt:    (define o0 (open-output-string))
remote-player.rkt:    (define r0 (new remote-player% [in i0][out o0]))
remote-player.rkt:  (define-syntax-rule 
remote-player.rkt:    (begin s (read-xml-from (open-input-string (get-output-string op)))))
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (define-values (a0 i0 o0 r0) (create-bundle "<signup name=\"hello\" />"))
remote-player.rkt:  (check-true
remote-player.rkt:   (cons? (regexp-match #px"(spieler|player)\\d\\d:hello" (signup-parser (run (send r0 go a0) o0)))))
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (define-values (a1 i1 o1 r1) (create-bundle "<void />"))
remote-player.rkt:  (check-equal? (state-parser (run (send r1 setup s0) o1)) s0)
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (define plain0 (with-output-to-string (lambda () (write-xml-to (turn-plain-writer A1 #f '())))))
remote-player.rkt:  (define-values (a2 i2 o2 r2) (create-bundle plain0)) ;; players place A1 no hotel no order
remote-player.rkt:  (define t (new turn% (current-state s0)))
remote-player.rkt:  (define-values (_t1 _h1 _o1) (send r2 take-turn t))
remote-player.rkt:  ; (state-place-tile s2 C3 TOWER)
remote-player.rkt:    (with-output-to-string
remote-player.rkt:       (write-xml-to (turn-merge-writer C3 TOWER))
remote-player.rkt:       (write-xml-to (booleans-writer '(#t)))
remote-player.rkt:       (write-xml-to (order-writer '())))))
remote-player.rkt:  (define-values (am im  om  ep2a) (create-bundle merge0))
remote-player.rkt:  (set-field! name ep2a "ep2a")
remote-player.rkt:  (define merge2 (with-output-to-string (lambda () (write-xml-to (booleans-writer '(#t))))))
remote-player.rkt:  (define-values (_1 bim bom ep2b) (create-bundle merge2))
remote-player.rkt:  (set-field! name ep2b "ep2b")
remote-player.rkt:  (define-values (_2 cim com ep2c) (create-bundle merge2))
remote-player.rkt:  (set-field! name ep2c "ep2c")
remote-player.rkt:  (define t2 (new turn% [current-state s2:s]))
remote-player.rkt:  (define-values (_t2 _h2 _o2) (send ep2a take-turn t2))
remote-player.rkt:  (check-equal? C3 _t2)
remote-player.rkt:  (check-equal? TOWER _h2)
remote-player.rkt:  (check-equal? '() _o2)
remote-player.rkt:  (check-true (state? (turn-parser (run (void) om))))
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (define b:str* (with-output-to-string (lambda () (write-xml-to (booleans-writer boolns)))))
remote-player.rkt:  (define-values (a3 i3 o3 r3) (create-bundle b:str*))
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (check-equal? r boolns)
remote-player.rkt:  (check-equal? (keeps-parser (run (void) o3)) hotels)
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (define-values (a4 i4 o4 r4) (create-bundle "<void />"))
remote-player.rkt:  (check-equal? (state-parser (run (send r4 inform s1) o4)) s1)
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (define-values (a5 i5 o5 r5) (create-bundle "<void />"))
remote-player.rkt:  (check-equal? (tile-parser (run (send r5 receive-tile A7) o5)) A7)
remote-player.rkt:  ;; -------------------------------------------------------------------------------------------------
remote-player.rkt:  (define-values (a6 i6 o6 r6) (create-bundle "<void />"))
remote-player.rkt:  (define score (state-score s1))
remote-player.rkt:  (check-equal? (end-parser (run (send r6 the-end s1 score) o6)) (cons s1 score)))
server-start.rkt:exec racket -tm "$0" ${1+"$@"}
server-start.rkt:;; ---------------------------------------------------------------------------------------------------
server-start.rkt:  ;; $ ./server-start.rkt port# player#
server-start.rkt:(require "admin.rkt" "basics.rkt" "state.rkt" "remote-player.rkt" 
server-start.rkt:;; Port#String NatString -> Score 
server-start.rkt:  (define port# (string->number port#:string))
server-start.rkt:  (define p# (string->number p#:string))
server-start.rkt:  (unless (and (integer? port#) (<= 0 port# 65535) (integer? p#) (<= MIN-PLAYER# p# MAX-PLAYER#))
server-start.rkt:    (error 'server-start "expected usage $ ./server-start port# player#"))
server-start.rkt:  (define tcp-listener (tcp-listen port# p# #t #f))
server-start.rkt:  (let accept-players-and-run-games ()
server-start.rkt:    (define admin (new administrator% [next-tile randomly-pick]))
server-start.rkt:    (define c (make-custodian))
server-start.rkt:    (parameterize ((current-custodian c))
server-start.rkt:      (accept-players p# tcp-listener admin)
server-start.rkt:      (run-one-game admin))
server-start.rkt:    (custodian-shutdown-all c)
server-start.rkt:    (accept-players-and-run-games)))
server-start.rkt:;; Administrator -> Void 
server-start.rkt:(define (run-one-game admin)
server-start.rkt:  (pretty-print `(ready to go with ,(send admin show-players)))
server-start.rkt:  (define-values (_1 score _2) (send admin run 99 #:show values #;(show)))
server-start.rkt:  (pretty-print score)
server-start.rkt:  (displayln (make-string 80 #\*)))
server-start.rkt:;; Nat TcpListener Administrator -> Void 
server-start.rkt:(define (accept-players p# tcp-listener admin)
server-start.rkt:    (define-values (in out) (tcp-accept tcp-listener))
server-start.rkt:    (define remote-proxy-player (new remote-player% [in in][out out]))
server-start.rkt:    (in-sandbox (lambda () (send remote-proxy-player go admin))
server-start.rkt:                (lambda (_) (accept-players (- p# 1) tcp-listener admin))
server-start.rkt:                (lambda (status) (accept-players (- p# 1) tcp-listener admin)))))
server-start.rkt:;; -> (Nat Board -> Void)
server-start.rkt:  (parameterize ((current-eventspace (make-eventspace)))
server-start.rkt:    (define canvas (new editor-canvas% [parent frame][editor paste]))
server-start.rkt:      (send paste begin-edit-sequence)
server-start.rkt:      (send paste select-all)
server-start.rkt:      (send paste insert (state-draw state) 0 0)
server-start.rkt:      (send paste end-edit-sequence)
server-start.rkt:;; --- run baby run 
state-intf.rkt:;; ---------------------------------------------------------------------------------------------------
state-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
state-intf.rkt:  (player? (-> any/c boolean?))
state-intf.rkt:  (player-money    (-> player? cash?))
state-intf.rkt:  (player-tiles    (-> player? (listof tile?)))
state-intf.rkt:  (player-shares   (-> player? shares?))
state-intf.rkt:  (player-external (-> player? any))
state-intf.rkt:  (player-name     (-> player? string?))
state-intf.rkt:   ;; (and/c (listof tile?) (位 (l) (= (length l) FULL-TILES)) distinct)
state-intf.rkt:   (->* (string? tile? tile? tile? tile? tile? tile?) (any/c) player?))
state-intf.rkt:  (xplayer?        (-> any/c any))
state-intf.rkt:  (player->xexpr   (-> player? xplayer?))
state-intf.rkt:  (*create-player 
state-intf.rkt:   ;; create a mid-game player from tiles, shares, and cash, throw away the name 
state-intf.rkt:   (-> string? cash? shares? (and/c [listof tile?] distinct (compose (<=/c STARTER-TILES#) length)) 
state-intf.rkt:  ;; ---------------------------------------------------------------------------------------------------
state-intf.rkt:  (state?               (-> any/c boolean?))
state-intf.rkt:  (state-hotels         (-> state? (listof hotel?)))
state-intf.rkt:  (state-shares         (-> state? shares?))
state-intf.rkt:  (state-sub-shares     (-> state? shares? state?))
state-intf.rkt:  (state-tiles          (-> state? (listof tile?)))
state-intf.rkt:  (state-board          (-> state? board?))
state-intf.rkt:  (state-players        (-> state? (listof player?)))
state-intf.rkt:  (state-current-player (-> state? player?))
state-intf.rkt:   (->* () () #:rest (and/c (listof player?) (位 (l) (distinct (apply append (map player-tiles l)))))
state-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
state-intf.rkt:  (state-place-tile
state-intf.rkt:   (->i ((s state?) (t tile?)) #;"optional" ((h hotel?))
state-intf.rkt:        (member t (player-tiles (state-current-player s)))
state-intf.rkt:        (not (eq? (what-kind-of-spot (state-board s) t) IMPOSSIBLE))
state-intf.rkt:        (or (unsupplied-arg? h) (memq (what-kind-of-spot (state-board s) t) (list FOUNDING MERGING)))
state-intf.rkt:        (let ((b (state-board s))
state-intf.rkt:              (hotels (state-hotels s)))
state-intf.rkt:          (==> (and (eq? (what-kind-of-spot b t) FOUNDING) (cons? hotels)) 
state-intf.rkt:               (and (not (unsupplied-arg? h)) (member h hotels))))
state-intf.rkt:        (==> (eq? (what-kind-of-spot (state-board s) t) MERGING) 
state-intf.rkt:             (and (not (unsupplied-arg? h)) 
state-intf.rkt:                  (let-values ([(w _) (merging-which (state-board s) t)]) (member h w))))
state-intf.rkt:        (next-state state?)))
state-intf.rkt:  (state-buy-shares
state-intf.rkt:   (->i ((s state?) (shares shares-order/c))
state-intf.rkt:        (affordable? (state-board s) shares (player-money (state-current-player s)))
state-intf.rkt:        (let ([banker-s-shares (state-shares s)])
state-intf.rkt:          (shares-available? banker-s-shares shares))
state-intf.rkt:        (next-state state?)))
state-intf.rkt:  (state-return-shares 
state-intf.rkt:   (->i ((s state?) (d (listof (list/c player? (listof (list/c hotel? boolean?))))))
state-intf.rkt:        #:pre (s d) (= (length (state-players s)) (length d))
state-intf.rkt:  (state-move-tile
state-intf.rkt:   (->i ((s state?) (t tile?)) 
state-intf.rkt:        #:pre/name (s t) "banker's tile?" (member t (state-tiles s))
state-intf.rkt:        (next-state state?)))
state-intf.rkt:  (state-next-turn 
state-intf.rkt:   (-> state? state?))
state-intf.rkt:  (state-remove-current-player
state-intf.rkt:   (-> state? state?))
state-intf.rkt:  (state-eliminate
state-intf.rkt:   (-> state? (listof player?) state?))
state-intf.rkt:  (state-score
state-intf.rkt:   (-> state? score/c))
state-intf.rkt:  (state-final?
state-intf.rkt:   (-> state? boolean?))
state-intf.rkt:  (state-draw
state-intf.rkt:   (-> state? image?))
state-intf.rkt:  ;; -------------------------------------------------------------------------------------------------
state-intf.rkt:  (xstate?       (-> any/c boolean?))
state-intf.rkt:  (state->xexpr  (-> state? xstate?))
state-intf.rkt:  [*create-state (->i ((b board?)
state-intf.rkt:			   ;; [Listof Player] -> Boolean 
state-intf.rkt:			     (define d (shares-combinable? (map player-shares lp)))
state-intf.rkt:			       (displayln `(shares not combinable ,(map player-shares lp))))
state-intf.rkt:                      (distinct (apply append (board-tiles b) (map player-tiles lp)))
state-intf.rkt:  [*cs0 (->* () #:rest (and/c (listof (and/c string? (位 (n) (<= (string-length n) 20)))) distinct)
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:;; -- inspecting the game state 
state.rkt:;; -- manipulating the game state 
state.rkt:(require "state-intf.rkt")
state.rkt: player? player-money player-tiles player-shares player-external player-name player0
state.rkt: xplayer? player->xexpr *create-player
state.rkt: state? state-hotels state-shares state-sub-shares state-tiles state-board state-players 
state.rkt: state-current-player
state.rkt: state-place-tile state-buy-shares state-return-shares state-move-tile state-next-turn 
state.rkt: state-remove-current-player state-eliminate state-score state-final? state-draw 
state.rkt: xstate? state->xexpr
state.rkt: *create-state *cs0)
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:;; -- t is the list of tiles the player owns 
state.rkt:;; -- a is the amount of available money 
state.rkt:;; -- s are the shares owned 
state.rkt:  (case-lambda 
state.rkt:     (player n (list t1 t2 t3 t4 t5 t6) CASH0 player-shares0 x)]
state.rkt:     (player n (list t1 t2 t3 t4 t5 t6) CASH0 player-shares0 #f)]
state.rkt:     (player n  v CASH0 player-shares0 #f)]))
state.rkt:(define (*create-player name cash shares tiles)
state.rkt:;; Player Tile -> Player 
state.rkt:(define (player-tile- p t)
state.rkt:  (struct-copy player p (tiles (remove t (player-tiles p)))))
state.rkt:;; Player Tile -> Player 
state.rkt:(define (player-tile+ p t)
state.rkt:  (struct-copy player p (tiles (cons t (player-tiles p)))))
state.rkt:;; Player [Listof Hotel] -> Player 
state.rkt:(define (player-shares++ p . h)
state.rkt:      (struct-copy player p (shares (for/fold ((s (player-shares p))) ((h h)) (shares++ s h))))))
state.rkt:;; Player ShareOrder Board -> Player 
state.rkt:(define (player-buy-shares p0 sh board)
state.rkt:  (define amount (for/sum ((h sh)) (price-per-share h (size-of-hotel board h))))
state.rkt:  (apply player-shares++ (struct-copy player p0 (money (- (player-money p0) amount))) sh))
state.rkt:;; Player Shares Board -> Player 
state.rkt:(define (player-returns-shares p0 transfers board)
state.rkt:  (struct-open player p0 shares money)
state.rkt:  (define amount (shares->money transfers board))
state.rkt:  (struct-copy player p0 (money (+ money amount)) (shares (shares-minus shares transfers))))
state.rkt:(define TEXT-SIZE 22) 
state.rkt:;; Player -> Image 
state.rkt:(define (player-image p)
state.rkt:  (struct-open player p name money tiles shares)
state.rkt:                       (text (format "~a :: owns $~a" name money) TEXT-SIZE 'red)
state.rkt:                       (text (string-join (map tile->string tiles)) TEXT-SIZE 'red)
state.rkt:                       (text (shares->string shares) TEXT-SIZE 'red)))
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:;; -- b is the current board 
state.rkt:;; -- p is the state of all the players 
state.rkt:;; -- t is the list of available tiles 
state.rkt:;; -- h is the list of available hotels 
state.rkt:;; -- s is the list of available shares 
state.rkt:;; -- bad is the list of players gone bad 
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:  (define tiles-owned-by-players (apply append (map player-tiles p)))
state.rkt:  (define tiles-in-pool (remove* tiles-owned-by-players ALL-TILES))
state.rkt:  (state (board) p tiles-in-pool ALL-HOTELS banker-shares0 '()))
state.rkt:(define (state-sub-shares s bad-shares)
state.rkt:  (struct-copy state s (shares (shares-minus (state-shares s) bad-shares))))
state.rkt:;; Player *-> State 
state.rkt:  (let loop ((names names) (tiles ALL-TILES) (players '()))
state.rkt:      [(empty? names) (state (board) (reverse players) tiles ALL-HOTELS banker-shares0)]
state.rkt:      [else (define first-six (take tiles STARTER-TILES#))
state.rkt:            (define player1 (player (first names) first-six CASH0 player-shares0))
state.rkt:            (loop (rest names) (drop tiles STARTER-TILES#) (cons player1 players))])))
state.rkt:;; Board [Listof Player] -> State
state.rkt:(define (*create-state board players)
state.rkt:  (define players-shares (map player-shares players))
state.rkt:  (define remaining-shares 
state.rkt:    (for/fold ((remaining-shares banker-shares0)) [(s players-shares)]
state.rkt:      (shares-minus remaining-shares s)))
state.rkt:  (define remaining-hotels 
state.rkt:    (for/list ((h ALL-HOTELS) #:when (= (size-of-hotel board h) 0)) h))
state.rkt:  (define remaining-tiles 
state.rkt:    (remove* (apply append (board-tiles board) (map player-tiles players)) ALL-TILES))
state.rkt:  (state board players remaining-tiles remaining-hotels remaining-shares '()))
state.rkt:;; State Tile [Hotel] -> State 
state.rkt:(define (state-place-tile s tile (hotel #f))
state.rkt:  (struct-open state s board hotels players shares tiles)
state.rkt:  (define current (player-tile- (first players) tile))
state.rkt:  (define players-next (cons current others))
state.rkt:  (define tiles-next (remove tile tiles))
state.rkt:  (define spot (what-kind-of-spot board tile))
state.rkt:     (define new-board 
state.rkt:           (grow-hotel board tile)
state.rkt:           (place-tile board tile)))
state.rkt:     (struct-copy state s (board new-board) (tiles tiles-next) (players players-next))]
state.rkt:       (struct-copy state s
state.rkt:                    (tiles tiles-next)
state.rkt:                    (board (found-hotel board tile hotel))))
state.rkt:     (if (= (shares-available shares hotel) 0)
state.rkt:      (struct-copy state t (players players-next))
state.rkt:      (struct-copy state t
state.rkt:                   (shares (shares-- shares hotel))
state.rkt:                   (players (cons (player-shares++ current hotel) others))))]
state.rkt:     (define-values (w l) (merging-which board tile))
state.rkt:     (define next-state
state.rkt:       (struct-copy state s
state.rkt:                    (board (merge-hotels board tile hotel))
state.rkt:                    (tiles tiles-next)
state.rkt:                    (players players-next)))
state.rkt:     (foldr (state-distribute-bonus board) next-state acquired)]))
state.rkt:;; [Listf Hotel Nat] State -> State 
state.rkt:(define ((state-distribute-bonus board) acquired-hotel s)
state.rkt:  (define size-acquired (size-of-hotel board acquired-hotel))
state.rkt:  (define players (state-players s))
state.rkt:  (define selector (lambda (p) (shares-available (player-shares p) acquired-hotel)))
state.rkt:  (define owners-of-acquired (filter (lambda (p) (> (selector p) 0)) players))
state.rkt:  (define owners-of-acquired-sorted (sort owners-of-acquired > #:key selector))
state.rkt:    [(empty? owners-of-acquired-sorted) s]
state.rkt:     (define majority-minority (partition owners-of-acquired-sorted selector))
state.rkt:     (define majority (first majority-minority))
state.rkt:     (define minority (if (empty? (rest majority-minority)) '() (second majority-minority)))
state.rkt:     (define majority-bonus (bonus 'majority acquired-hotel size-acquired))
state.rkt:     (define minority-bonus (bonus 'minority acquired-hotel size-acquired))
state.rkt:        (define total-bonus (+ majority-bonus minority-bonus))
state.rkt:        (define bonus-per (quotient total-bonus (length majority)))
state.rkt:        (struct-copy state s (players (foldr (state-pay-out bonus-per) players majority)))]
state.rkt:        (define single-majority (first majority))
state.rkt:        (define majority-payed ((state-pay-out majority-bonus) single-majority players))
state.rkt:        (define bonus-per (quotient minority-bonus (length minority)))
state.rkt:        (struct-copy state s (players (foldr (state-pay-out bonus-per) majority-payed minority)))]
state.rkt:        (define single-majority (first majority))
state.rkt:        (struct-copy state s (players ((state-pay-out majority-bonus) single-majority players)))])]))
state.rkt:;; Cash -> (Player [Listof Players] -> [Listof Player])
state.rkt:(define (state-pay-out bonus)
state.rkt:  ;; add cash to wallet of pay-to in players
state.rkt:  (lambda (pay-to players)
state.rkt:    (define the-name (player-name pay-to))
state.rkt:      (struct-open player p name money)
state.rkt:      (if (string=? name the-name) (struct-copy player p (money (+ money bonus))) p))))
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:(define (state-move-tile s t)
state.rkt:  (struct-open state s players tiles)
state.rkt:  (struct-copy state s 
state.rkt:               (players (cons (player-tile+ (first players) t) (rest players)))
state.rkt:(define (state-next-turn s)
state.rkt:  (define players (state-players s))
state.rkt:  (struct-copy state s (players (append (rest players) (list (first players))))))
state.rkt:(define (state-remove-current-player s)
state.rkt:  (define players (state-players s))
state.rkt:  (struct-copy state s (players (rest players)) (bad (cons (first players) (state-bad s)))))
state.rkt:(define (state-eliminate s ep)
state.rkt:  (struct-copy state s (players (remove* ep (state-players s))) (bad (append ep (state-bad s)))))
state.rkt:(define (state-current-player s)
state.rkt:  (first (state-players s)))
state.rkt:(define (state-buy-shares s sh)
state.rkt:  (struct-open state s players board shares)
state.rkt:  (struct-copy state s 
state.rkt:               (players (cons (player-buy-shares (first players) sh board) (rest players)))
state.rkt:               (shares (for/fold ((s shares)) ((h sh)) (shares-- s h)))))
state.rkt:(define (state-return-shares s decisions (board (state-board s)))
state.rkt:    (state-return-shares/player s (first d) (second d) board)))
state.rkt:;; State Player [Listof [List Hotel Any]] -> State 
state.rkt:(define (state-return-shares/player s p p-s-decisions (board (state-board s)))
state.rkt:  (define the-name (player-name p))
state.rkt:  (define player-s (player-shares p))
state.rkt:  (define transfers (shares-to-be-moved+their-value player-s p-s-decisions))
state.rkt:  (struct-open state s players shares)
state.rkt:  (define new-players 
state.rkt:      (if (string=? (player-name q) the-name)
state.rkt:          (player-returns-shares q transfers board)
state.rkt:  (struct-copy state s (shares (shares-plus shares transfers)) (players new-players)))
state.rkt:;; Board Shares [Listof [List Hotel Boolean]] -> Shares 
state.rkt:;; determine how the shares that must be transfered from player-s-shares to banker-s-shares 
state.rkt:(define (shares-to-be-moved+their-value player-s-shares decisions)
state.rkt:  (for/fold ((shares player-shares0)) ((d decisions))
state.rkt:      [else (define available (shares-available player-s-shares hotel))
state.rkt:            (for/fold ((shares shares)) ((n (in-range available))) (shares++ shares hotel))])))
state.rkt:(define (state-score s0)
state.rkt:  (define board (state-board s0))
state.rkt:  (define bonus (state-distribute-bonus board))
state.rkt:    (foldr (lambda (h s) (if (= (size-of-hotel board h) 0) s (bonus h s))) s0 ALL-HOTELS))
state.rkt:    (for/list ((p (state-players state/bonus)))
state.rkt:      (struct-open player p name money shares)
state.rkt:      (list name (+ money (shares->money shares board)))))
state.rkt:(define (shares->money shares board)
state.rkt:    (define size (size-of-hotel board hotel))
state.rkt:    (define price (price-per-share hotel size))
state.rkt:(define (state-final? s)
state.rkt:  (define board  (state-board s))
state.rkt:  (define-values (winner? founded safe)
state.rkt:    (for/fold ((winner? #f) (founded '()) (safe '())) ((h ALL-HOTELS))
state.rkt:      (define s (size-of-hotel board h))
state.rkt:(define (state-draw s)
state.rkt:  (struct-open state s board players)
state.rkt:  (define players:image (map player-image players))
state.rkt:                 [(empty? players:image) empty-image]
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:;; State -> Xexpr
state.rkt:(define (state->xexpr s)
state.rkt:  (struct-open state s players board)
state.rkt:  `(state () ,(board->xexpr board) ,@(map player->xexpr players)))
state.rkt:;; Player -> Xexpr 
state.rkt:(define (player->xexpr p)
state.rkt:  (struct-open player p tiles name money shares)
state.rkt:  `(player ((name ,name) (cash ,(cash->string money))) 
state.rkt:           ,@(shares->xexpr shares)
state.rkt:           ,@(map tile->xexpr (sort tiles tile<=?))))
state.rkt:  (xml-predicate (player ((name string?) (cash string->cash)) xshare? ... xtile? ...)))
state.rkt:  (xml-predicate (state () xboard? xplayer? ... )))
state.rkt:;; ---------------------------------------------------------------------------------------------------
state.rkt:  (define-syntax (test-place-tile stx)
state.rkt:    (syntax-case stx (--bonus--)
state.rkt:      [(test-place-tile merger? (board b*) (tile t*) (hotel h* all-h) players-1 next-tiles expected)
state.rkt:       #'(test-place-tile merger? (board b*) (tile t*) (hotel h* all-h) 
state.rkt:                          --bonus-- (('none 0 0)) players-1 next-tiles expected)]
state.rkt:      [(test-place-tile merger? (board b*) (tile t*) players-1 next-tiles expected)
state.rkt:       #'(test-place-tile merger? (board b*) (tile t*) (hotel #f ALL-HOTELS) 
state.rkt:                          --bonus-- (('none 0 0)) players-1 next-tiles expected)]
state.rkt:      [(test-place-tile merger? (board b*) (tile t*) (hotel h* all-h)
state.rkt:                        --bonus-- ((acquired no-shares pay-out) ...) players-1 next-tiles expected)
state.rkt:           (define extra-tiles (list (ctile A 2) (ctile A 3) (ctile A 4)))
state.rkt:           (define shares-player 
state.rkt:             (for/fold ((ps player-shares0)) ((a (list acquired ...)) (i (list no-shares ...)))
state.rkt:           (define player-0 
state.rkt:             (player "a" (cons tile extra-tiles) CASH0 shares-player #f))
state.rkt:           (define extra-player
state.rkt:             (player "b" '() CASH0 player-shares0 #f))
state.rkt:           (define next-tiles (remove tile ALL-TILES))
state.rkt:           (define state-0
state.rkt:             (state board (list player-0 extra-player) next-tiles all-h banker-shares0 '()))
state.rkt:           (define players-1
state.rkt:                      extra-tiles
state.rkt:                      (+ CASH0 pay-out ...)
state.rkt:                          (shares++ shares-player hotel)
state.rkt:                          shares-player)
state.rkt:              extra-player))
state.rkt:           (check-equal? 
state.rkt:            (if hotel (state-place-tile state-0 tile hotel) (state-place-tile state-0 tile)) 
state.rkt:  ;; --- placing a tile as a singleton --- 
state.rkt:  (test-place-tile SINGLETON
state.rkt:                   p p-tiles 
state.rkt:                   (state (place-tile b t) p p-tiles ALL-HOTELS banker-shares0 '()))
state.rkt:  ;; --- growing a hotel ---
state.rkt:  (test-place-tile GROWING
state.rkt:                   (b board-a2-b2-american)
state.rkt:                   p p-tiles 
state.rkt:                   (state (grow-hotel b t) p p-tiles ALL-HOTELS banker-shares0 '()))
state.rkt:  ;; --- placing a founding tile on board --- 
state.rkt:  (test-place-tile FOUNDING
state.rkt:                   (b board-a1-b2-c6)
state.rkt:                   (h AMERICAN ALL-HOTELS)
state.rkt:                   p p-tiles 
state.rkt:                   (state (found-hotel b t h) p p-tiles (remove h ALL-HOTELS) 
state.rkt:                          (shares-- banker-shares0 h)
state.rkt:  ;; --- merging a hotel chain: no owner --- 
state.rkt:  (test-place-tile MERGING 
state.rkt:                   (b board-b2-c2-am-c4-d4-tw-e4)
state.rkt:                   (h TOWER (remove* `(,TOWER ,AMERICAN) ALL-HOTELS))
state.rkt:                   new-players p-tiles 
state.rkt:                   (state (merge-hotels b t h) new-players p-tiles (remove h ALL-HOTELS) 
state.rkt:                          banker-shares0
state.rkt:  ;; --- merging a hotel chain: one majority owner --- 
state.rkt:  (test-place-tile MERGING 
state.rkt:                   (b board-b2-c2-am-c4-d4-tw-e4)
state.rkt:                   (h TOWER (remove* `(,TOWER ,AMERICAN) ALL-HOTELS))
state.rkt:                   --bonus-- ((AMERICAN 3 (bonus 'majority AMERICAN 2)))
state.rkt:                   p p-tiles 
state.rkt:                   (state (merge-hotels b t h) p p-tiles (remove h ALL-HOTELS) banker-shares0 '()))
state.rkt:  ;; --- merging three hotel chains: one majority and one minority owner 
state.rkt:  (test-place-tile MERGING 
state.rkt:                   (b board-3way-merger-at-d3)
state.rkt:                   (h TOWER (remove* `(,TOWER ,AMERICAN ,WORLDWIDE) ALL-HOTELS))
state.rkt:                   --bonus-- ((AMERICAN 3 (bonus 'majority AMERICAN 3))
state.rkt:                   (state (merge-hotels b t h) ;; one hotel left 
state.rkt:                          p ;; bonus-added to player 1 
state.rkt:                          (list* AMERICAN WORLDWIDE (remove* `(,TOWER ,AMERICAN ,WORLDWIDE) ALL-HOTELS))
state.rkt:                          banker-shares0 
state.rkt:  ;; --- merging with three majority owners 
state.rkt:  (define board-b2-c2-am-c4-d4-tw-e4-c3-d3 (merge-hotels board-b2-c2-am-c4-d4-tw-e4 C3 TOWER))
state.rkt:  (define bouns-3-majority-owners (+ (quotient maj 3) (quotient min 3) 6000))
state.rkt:  (check-equal? (state-place-tile 
state.rkt:                 (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:                        (list (player "a" (list C3) 6000 (shares++ player-shares0 AMERICAN) #f)
state.rkt:                              (player "b" '() 6000 (shares++ player-shares0 AMERICAN) #f)
state.rkt:                              (player "c" '() 6000 (shares++ player-shares0 AMERICAN) #f))
state.rkt:                        ALL-TILES
state.rkt:                        (remove* `(,TOWER ,AMERICAN) ALL-HOTELS)
state.rkt:                        banker-shares0
state.rkt:                 board-b2-c2-am-c4-d4-tw-e4-c3-d3
state.rkt:                 (list (player "a" '() bouns-3-majority-owners (shares++ player-shares0 AMERICAN) #f)
state.rkt:                       (player "b" '() bouns-3-majority-owners (shares++ player-shares0 AMERICAN) #f)
state.rkt:                       (player "c" '() bouns-3-majority-owners (shares++ player-shares0 AMERICAN) #f))
state.rkt:                 (remove C3 ALL-TILES)
state.rkt:                 (remove TOWER ALL-HOTELS)
state.rkt:                 banker-shares0
state.rkt:  ;; -- merger case with one majority and one minority owner 
state.rkt:  (check-equal? 
state.rkt:   (state-place-tile
state.rkt:    (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:           (list (player "a" (list C3) 6000 (shares++ (shares++ player-shares0 AMERICAN) AMERICAN) #f)
state.rkt:                 (player "b" '() 6000 (shares++ player-shares0 AMERICAN) #f)
state.rkt:                 (player "c" '() 6000 player-shares0 #f))
state.rkt:           ALL-TILES
state.rkt:           (remove* `(,TOWER ,AMERICAN) ALL-HOTELS)
state.rkt:           banker-shares0
state.rkt:   (state board-b2-c2-am-c4-d4-tw-e4-c3-d3
state.rkt:          (list (player "a" '() (+ maj 6000) (shares++ (shares++ player-shares0 AMERICAN) AMERICAN) #f)
state.rkt:                (player "b" '() (+ min 6000) (shares++ player-shares0 AMERICAN) #f)
state.rkt:                (player "c" '() 6000 player-shares0 #f))
state.rkt:          (remove C3 ALL-TILES)
state.rkt:          (remove TOWER ALL-HOTELS)
state.rkt:          banker-shares0
state.rkt:  ;; -- merger case with one majority and two minority owners 
state.rkt:  (check-equal? 
state.rkt:   (state-place-tile
state.rkt:    (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:           (list (player "a" (list C3) 6000 (shares++ (shares++ player-shares0 AMERICAN) AMERICAN) #f)
state.rkt:                 (player "b" '() 6000 (shares++ player-shares0 AMERICAN) #f)
state.rkt:                 (player "c" '() 6000 (shares++ player-shares0 AMERICAN) #f))
state.rkt:           ALL-TILES
state.rkt:           (remove* `(,TOWER ,AMERICAN) ALL-HOTELS)
state.rkt:           banker-shares0
state.rkt:   (state board-b2-c2-am-c4-d4-tw-e4-c3-d3
state.rkt:          (list (player "a" '() (+ maj 6000) (shares++ (shares++ player-shares0 AMERICAN) AMERICAN) #f)
state.rkt:                (player "b" '() (+ min/2 6000) (shares++ player-shares0 AMERICAN) #f)
state.rkt:                (player "c" '() (+ min/2 6000) (shares++ player-shares0 AMERICAN) #f))
state.rkt:          (remove C3 ALL-TILES)
state.rkt:          (remove TOWER ALL-HOTELS)
state.rkt:          banker-shares0
state.rkt:  ;; --- moving a tile from the banker's pool to the current players 
state.rkt:  (check-equal? (state-move-tile (state0 (player0 "a")) (ctile A 1)) (state0 (player0 "a" (ctile A 1))))
state.rkt:  ;; --- switching turns 
state.rkt:  (check-equal? (state-next-turn (state0 (player0 (ctile A 1)))) (state0 (player0 (ctile A 1))))
state.rkt:  (check-equal? (state-next-turn 
state.rkt:  ;; --- banker sells shares to current player ---
state.rkt:  (define s (state board-b2-c2-am-c4-d4-tw-e4 (list p) ALL-TILES ALL-HOTELS banker-shares0 '()))
state.rkt:  (check-equal? (state-buy-shares s (list AMERICAN TOWER AMERICAN))
state.rkt:                (let* ([ps player-shares0]
state.rkt:                       [ss banker-shares0]
state.rkt:                       [ss (shares-- ss AMERICAN)]
state.rkt:                       [ss (shares-- ss AMERICAN)]
state.rkt:                       [ss (shares-- ss TOWER)])
state.rkt:                  (struct-copy state s
state.rkt:                                              (- CASH0
state.rkt:                                                 (* 2 (price-per-share AMERICAN 2))
state.rkt:                                                 (price-per-share TOWER 3))
state.rkt:  ;; -------------------------------------------------------------------------------------------------
state.rkt:  (define state-not-final
state.rkt:  (check-false (state-final? state-not-final))
state.rkt:  (state-draw state-not-final)
state.rkt:  (define American-safe-tiles (build-list SAFE# (lambda (i) (ctile C (+ i 1)))))
state.rkt:  (define b-with-one-safe-hotel (*create-board-with-hotels '() `((,AMERICAN ,@American-safe-tiles))))
state.rkt:  ;; --- final state testing and scoring for a state with a board that contains of ONE safe hotel 
state.rkt:  (define s-with-one-safe-hotel 
state.rkt:    (state b-with-one-safe-hotel (list p) ALL-TILES ALL-HOTELS banker-shares0 '()))
state.rkt:  (check-true (state-final? s-with-one-safe-hotel))
state.rkt:  (check-equal? (state-score s-with-one-safe-hotel) (list (list (player-name p) (player-money p))))
state.rkt:  ;; --- final state testing and scoring for board with a final hotel 
state.rkt:  (define Continental-final-tiles
state.rkt:     (build-list SAFE# (lambda (i) (ctile E (+ i 1))))
state.rkt:     (build-list SAFE# (lambda (i) (ctile F (+ i 1))))
state.rkt:     (build-list SAFE# (lambda (i) (ctile G (+ i 1))))
state.rkt:     (build-list SAFE# (lambda (i) (ctile H (+ i 1))))))
state.rkt:  (define American-non-safe-tiles
state.rkt:    (build-list (- SAFE# 1) (lambda (i) (ctile C (+ i 1)))))
state.rkt:  (unless (>= (length Continental-final-tiles) FINAL#)
state.rkt:    (check-true #f))
state.rkt:  (define b-with-final-hotel
state.rkt:    (*create-board-with-hotels 
state.rkt:     `((,AMERICAN ,@American-non-safe-tiles)
state.rkt:       (,CONTINENTAL ,@Continental-final-tiles))))
state.rkt:  (define s-with-final-hotel
state.rkt:    (state b-with-final-hotel 
state.rkt:           ALL-TILES 
state.rkt:           (remove* (list AMERICAN CONTINENTAL) ALL-HOTELS)
state.rkt:           banker-shares0
state.rkt:  (check-true (state-final? s-with-final-hotel))
state.rkt:  (check-equal? (state-score s-with-final-hotel) (list (list (player-name p) (player-money p))))
state.rkt:  ;; --- scoring for two players w/o ownership
state.rkt:  (define s-with-final-hotel2
state.rkt:    (state b-with-final-hotel 
state.rkt:           ALL-TILES 
state.rkt:           (remove* (list AMERICAN CONTINENTAL) ALL-HOTELS)
state.rkt:           banker-shares0
state.rkt:  (check-equal? (state-score s-with-final-hotel2) 
state.rkt:                (list (list (player-name p) (player-money p))
state.rkt:                      (list (player-name pb) (player-money pb))))
state.rkt:  ;; --- scoring with player who owns shares of a hotel that does not exist 
state.rkt:  (define pbad (player "bad" (list (ctile A 2)) CASH0 (shares++ player-shares0 AMERICAN) #f))
state.rkt:  (check-equal? (state-score (state (board) (list pbad) ALL-TILES ALL-HOTELS banker-shares0 '()))
state.rkt:                (list (list (player-name pbad) (player-money pbad))))
state.rkt:  ;; --- scoring with two owners (majority and minority) for one hotel   
state.rkt:    (player "c" (list (ctile A 2)) CASH0 (shares++ (shares++ player-shares0 AMERICAN) AMERICAN) #f))
state.rkt:  (define portfolio-a (shares++ player-shares0 AMERICAN))
state.rkt:  (define pa (player "a" (list (ctile A 2)) CASH0 portfolio-a #f))
state.rkt:  (define s-with-final-hotel3
state.rkt:    (state b-with-final-hotel 
state.rkt:           ALL-TILES 
state.rkt:           (remove* (list AMERICAN CONTINENTAL) ALL-HOTELS)
state.rkt:           banker-shares0
state.rkt:  (define (p-money pc status)
state.rkt:    (+ (bonus status AMERICAN (length American-non-safe-tiles))
state.rkt:       (*  (hash-ref (player-shares pc) AMERICAN) 
state.rkt:           (price-per-share AMERICAN (length American-non-safe-tiles)))
state.rkt:       (player-money pc)))
state.rkt:  (check-equal? (state-score s-with-final-hotel3) 
state.rkt:                (list (list (player-name pc) (p-money pc 'majority))
state.rkt:                      (list (player-name pa) (p-money pa 'minority))))
state.rkt:  ;; --- which shares to move from players to bank, what is their value 
state.rkt:  (define American-non-safe-size (length American-non-safe-tiles))
state.rkt:  (define s1 (shares-to-be-moved+their-value player-shares0 `((,AMERICAN #t))))
state.rkt:  (check-equal? s1 player-shares0)
state.rkt:  (define shares0 (shares-available banker-shares0 AMERICAN))
state.rkt:  (define s2 (shares-to-be-moved+their-value banker-shares0 `((,AMERICAN #f))))
state.rkt:  (check-equal? s2 (for/fold ((sh player-shares0)) ((n (in-range shares0))) (shares++ sh AMERICAN)))
state.rkt:  (define s3 (shares-to-be-moved+their-value portfolio-a `((,AMERICAN #f))))
state.rkt:  (check-equal? s3 portfolio-a)
state.rkt:  ;; --- perform move of shares for one player 
state.rkt:  (define price-per-AMERICAN (price-per-share AMERICAN American-non-safe-size))
state.rkt:  (check-equal? 
state.rkt:   (state-return-shares/player s-with-final-hotel3 pa `((,AMERICAN #f)))
state.rkt:   (state b-with-final-hotel
state.rkt:          (list pc (player "a" (list (ctile A 2)) (+ CASH0 price-per-AMERICAN) player-shares0 #f))
state.rkt:          ALL-TILES 
state.rkt:          (remove* (list AMERICAN CONTINENTAL) ALL-HOTELS)
state.rkt:          (shares++ banker-shares0 AMERICAN)
state.rkt:  ;; --- and for two 
state.rkt:  (check-equal? 
state.rkt:   (state-return-shares s-with-final-hotel3 `((,pa ((,AMERICAN #f))) (,pc ((,CONTINENTAL #f)))))
state.rkt:   (state b-with-final-hotel
state.rkt:          (list pc (player "a" (list (ctile A 2)) (+ CASH0 price-per-AMERICAN) player-shares0 #f))
state.rkt:          ALL-TILES 
state.rkt:          (remove* (list AMERICAN CONTINENTAL) ALL-HOTELS)
state.rkt:          (shares++ banker-shares0 AMERICAN)
state.rkt:  (check-equal? 
state.rkt:   (state-return-shares s-with-final-hotel3 `((,pa ((,AMERICAN #f))) (,pc ((,AMERICAN #f)))))
state.rkt:   (state b-with-final-hotel
state.rkt:           (player "c" (list (ctile A 2)) (+ CASH0 (* 2 price-per-AMERICAN)) player-shares0 #f)
state.rkt:           (player "a" (list (ctile A 2)) (+ CASH0 price-per-AMERICAN) player-shares0 #f))
state.rkt:          ALL-TILES 
state.rkt:          (remove* (list AMERICAN CONTINENTAL) ALL-HOTELS)
state.rkt:          (shares++ (shares++ (shares++ banker-shares0 AMERICAN) AMERICAN) AMERICAN)
state.rkt:  ;; --- test state-return-shares under the same conditions as used in tree
state.rkt:  (define shares-for-am-tw-ww 
state.rkt:    (*combine-shares
state.rkt:     (list (*create-shares AMERICAN 3) (*create-shares TOWER 3) (*create-shares WORLDWIDE 3))))
state.rkt:  (define player-can-place-d3 (*create-player "a" 1000 shares-for-am-tw-ww (list D3)))
state.rkt:  (define state-merge-at-d3 (*create-state board-3way-merger-at-d3 (list player-can-place-d3)))
state.rkt:  (define d* `((,player-can-place-d3 ,(map (lambda (h) (list h #f)) acquired))))
state.rkt:  (define state/tile (state-place-tile state-merge-at-d3 D3 TOWER))
state.rkt:  (check-equal? (player-money (first (state-players (state-return-shares state/tile d* board-3way-merger-at-d3))))
state.rkt:                (+ (player-money player-can-place-d3)
state.rkt:                     (+ (bonus 'majority h (size-of-hotel board-3way-merger-at-d3 h))
state.rkt:                        (* (shares-available shares-for-am-tw-ww h)
state.rkt:                           (price-per-share h (size-of-hotel board-3way-merger-at-d3 h)))))))
state.rkt:  ;; --- removing players 
state.rkt:  (define p1 (player "1" '() 0 player-shares0 #f))
state.rkt:  (define p2 (player "2" '() 0 player-shares0 #f))
state.rkt:  (define p3 (player "3" '() 0 player-shares0 #f))
state.rkt:  (define s0 (state (board) (list p1 p2 p3) ALL-TILES ALL-HOTELS banker-shares0 '()))
state.rkt:  (define s0-removed (state (board) (list p2) ALL-TILES ALL-HOTELS banker-shares0 (list p1 p3)))
state.rkt:  (check-equal? (state-eliminate s0 (list p1 p3)) s0-removed)
state.rkt:(module+ sample-states 
state.rkt:  (provide s0 s1 s2 s0-name s3-merge-player-gets-bonus-can-buy)
state.rkt:    (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:           (remove* (list A1 B2 C2 C4 D4 E4) ALL-TILES)
state.rkt:           (remove* (list AMERICAN TOWER) ALL-HOTELS)
state.rkt:           banker-shares0
state.rkt:  (define (s0-name name)
state.rkt:    (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:           (remove* (list A1 B2 C2 C4 D4 E4) ALL-TILES)
state.rkt:           (remove* (list AMERICAN TOWER) ALL-HOTELS)
state.rkt:           banker-shares0
state.rkt:    (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:                 (player "b" (list A11) CASH0 (shares++ player-shares0 AMERICAN) #f))
state.rkt:           (remove* (list A1 B2 C2 C4 D4 E4 A11) ALL-TILES)
state.rkt:           (remove* (list AMERICAN TOWER) ALL-HOTELS)
state.rkt:           (shares-- banker-shares0 AMERICAN)
state.rkt:    (define p2a (player "a" (list C3) 6000 (shares++ (shares++ player-shares0 AMERICAN) AMERICAN) ep2a))
state.rkt:    (define p2b (player "b" '() 6000 (shares++ player-shares0 AMERICAN) ep2b))
state.rkt:    (define p2c (player "c" '() 6000 (shares++ player-shares0 AMERICAN) ep2c))
state.rkt:    (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:           (remove* (list B2 C2 C4 D4 E4 C3) ALL-TILES)
state.rkt:           (remove* `(,TOWER ,AMERICAN) ALL-HOTELS)
state.rkt:           (for/fold ((s banker-shares0)) [(n (in-range 4))] (shares-- s AMERICAN))
state.rkt:  (define (s3-merge-player-gets-bonus-can-buy sh)
state.rkt:    (state board-b2-c2-am-c4-d4-tw-e4
state.rkt:           (list (player "a" (list C3) 300 (shares++ (shares++ player-shares0 AMERICAN) AMERICAN) #f)
state.rkt:                 (player "b" '() 6000 (shares++ player-shares0 AMERICAN) #f)
state.rkt:                 (player "c" '() 6000 player-shares0 #f))
state.rkt:           (remove* (list B2 C2 C4 D4 E4 C3) ALL-TILES)
state.rkt:           (remove* `(,TOWER ,AMERICAN) ALL-HOTELS)
strategy-intf.rkt:;; ---------------------------------------------------------------------------------------------------
strategy-intf.rkt:  [ordered-s 
strategy-intf.rkt:   (make-strategy/c tile<?)]
strategy-intf.rkt:  [random-s
strategy-intf.rkt:  [largest-alpha 
strategy-intf.rkt:   (make-strategy/c tile>?)]
strategy-intf.rkt:  [smallest-anti
strategy-intf.rkt:   ;; 2. choose to buy as many shares as possible in ANTI-ALPHABETICAL order, but sort those on return
strategy-intf.rkt:   (make-strategy/c tile<?)])
strategy-intf.rkt:;; ---------------------------------------------------------------------------------------------------
strategy-intf.rkt:;; [Tile Tile -> Tile] -> Contract
strategy-intf.rkt:;; compare placement to all tiles t in player-s-tiles that pass (cmp t tile)
strategy-intf.rkt:(define (make-strategy/c cmp)
strategy-intf.rkt:  (->i ((turn (instanceof/c turn-player/c)))
strategy-intf.rkt:       (values (tile (turn) (and/c (maybe/c tile?) (good-placement turn) (unique-tile turn cmp)))
strategy-intf.rkt:               (hotel (tile turn) (and/c (maybe/c hotel?) (good-hotel-for-placement turn tile)))
strategy-intf.rkt:               (buy-order (tile hotel turn) (and/c (listof hotel?) (good-shares turn tile hotel))))))
strategy-intf.rkt:(define strategy/c (make-strategy/c (lambda (s t) #f)))
strategy-intf.rkt:;; ---------------------------------------------------------------------------------------------------
strategy-intf.rkt:;; (check-true ((others-not-placable (board) (list (ctile A 1)) tile<?) (ctile A 1)))
strategy-intf.rkt:;; (check-false ((others-not-placable (board) (list (ctile A 1)) tile<?) (ctile A 2)))
strategy-intf.rkt:;; (check-true ((others-not-placable (board) (list (ctile A 1)) tile>?) (ctile A 1)))
strategy-intf.rkt:;; (check-false ((others-not-placable (board) (list (ctile A 3)) tile>?) (ctile A 2)))
strategy-intf.rkt:(define/contract (unique-tile turn cmp)
strategy-intf.rkt:  (-> (instanceof/c turn-player/c) (-> tile? tile? any) (-> (maybe/c tile?) any))
strategy-intf.rkt:    (define board (get-field board turn))
strategy-intf.rkt:    (define player-s-tiles (get-field tiles turn))
strategy-intf.rkt:             (for/and ((t (filter (lambda (t) (cmp t tile)) player-s-tiles)))
strategy-intf.rkt:               (eq? (what-kind-of-spot board t) IMPOSSIBLE))))))
strategy.rkt:;; ---------------------------------------------------------------------------------------------------
strategy.rkt:(require "strategy-intf.rkt")
strategy.rkt:(strategy& ordered-s random-s largest-alpha smallest-anti)
strategy.rkt:;; ---------------------------------------------------------------------------------------------------
strategy.rkt:;; (cons Hotel [Listof Hotel]) -> Hotel 
strategy.rkt:(define (alphabetically-first w)
strategy.rkt:;; [ [Listof Hotel] [Listof Hotel] -> Hotel ] -> [Option Hotel]
strategy.rkt:(define (pick-hotel b to-place kind available-hotels select-founding-hotel select-merger)
strategy.rkt:     (and (cons? available-hotels) (select-founding-hotel available-hotels))]
strategy.rkt:     (define-values (w _) (merging-which b to-place))
strategy.rkt:     (select-merger w)]
strategy.rkt:;; Board Cash Shares N [ [Listof Hotel] -> [Listof Hotel] ] -> [Listof Hotel]
strategy.rkt:(define (to-buy b my-cash available-shares BUY-N ordering)
strategy.rkt:  (let loop ((hotels (ordering ALL-HOTELS)) (n 0) (to-buy '()) (cash my-cash) (as available-shares))
strategy.rkt:      [(or (empty? hotels) (= BUY-N n)) (reverse to-buy)]
strategy.rkt:       (define available-h (shares-available as h))
strategy.rkt:         [(= 0 available-h) (loop (rest hotels) n to-buy cash as)]
strategy.rkt:         [else (define price (price-per-share h (size-of-hotel b h)))
strategy.rkt:                   (if (and (<= (* 2 price) cash) (> available-h 1))
strategy.rkt:                   (loop (rest hotels) n to-buy cash as))])])))
strategy.rkt:;; (strategy for-loop [ [Listof Hotel] -> Hotel ] [ [Listof Hotel] -> Hotel ] [Nat -> Nat] 
strategy.rkt:;; -> 
strategy.rkt:;; where (for-loop iteration-clause body ...) computes an optional tile placement/action pair
strategy.rkt:;;       choose-founding picks a hotel to be founded 
strategy.rkt:;;       choose-merger   picks the hotel from the winners that is to be the acuirere 
strategy.rkt:;;       choose-shares#  determines how many shares are to be bought 
strategy.rkt:;;       hotel-ordering  orders the hotels, which determines in which order shares are bought
strategy.rkt:(define-syntax strategy
strategy.rkt:  (syntax-rules ()
strategy.rkt:    [(strategy for choose-founding choose-merger)
strategy.rkt:     (strategy for choose-founding choose-merger values values)]
strategy.rkt:    [(strategy for choose-founding choose-merger choose-shares# hotel-ordering)
strategy.rkt:       (define b (get-field board turn))
strategy.rkt:       (define my-tiles (get-field tiles turn))
strategy.rkt:       (define my-cash (get-field cash turn))
strategy.rkt:       (define available-shares (get-field shares turn))
strategy.rkt:       (define available-hotels (get-field hotels turn))
strategy.rkt:       (define tile-kind
strategy.rkt:         (for ((t (sort my-tiles tile<=?))
strategy.rkt:               (let ([s (what-kind-of-spot b t)])
strategy.rkt:           (list t (what-kind-of-spot b t))))
strategy.rkt:         [tile-kind
strategy.rkt:          (define-values (to-place kind) (apply values tile-kind))
strategy.rkt:          (define hotel  (pick-hotel b to-place kind available-hotels choose-founding choose-merger))
strategy.rkt:          (define board  (set-board b to-place kind hotel))
strategy.rkt:            (if (and (eq? FOUNDING kind) hotel (> (shares-available available-shares hotel) 0))
strategy.rkt:                (shares-- available-shares hotel)
strategy.rkt:                available-shares))
strategy.rkt:            (send turn place to-place hotel))
strategy.rkt:          (values to-place hotel (to-buy board my-cash shares SHARES-PER-TURN# hotel-ordering))]
strategy.rkt:            (to-buy b my-cash available-shares (choose-shares# SHARES-PER-TURN#) hotel-ordering))
strategy.rkt:[define (strategy/d choose-founding choose-merger choose-shares# hotel-ordering)
strategy.rkt:    (define b (get-field board turn))
strategy.rkt:    (define my-cash (get-field cash turn))
strategy.rkt:    (define available-shares (get-field shares turn))
strategy.rkt:    (define available-hotels (get-field hotels turn))
strategy.rkt:    (define tile-kind
strategy.rkt:      (for ((t (sort (get-field tiles turn) tile<=?))
strategy.rkt:            (let ([s (what-kind-of-spot b t)])
strategy.rkt:        (list t (what-kind-of-spot b t))))
strategy.rkt:      [tile-kind
strategy.rkt:       (define-values (to-place kind) (apply values tile-kind))
strategy.rkt:       (define hotel  (pick-hotel b to-place kind available-hotels choose-founding choose-merger))
strategy.rkt:       (define board  (set-board b to-place kind hotel))
strategy.rkt:         (if (and (eq? FOUNDING kind) hotel (> (shares-available available-shares hotel) 0))
strategy.rkt:             (shares-- available-shares hotel)
strategy.rkt:             available-shares))
strategy.rkt:         (send turn place to-place hotel))
strategy.rkt:       (values to-place hotel (to-buy board my-cash shares SHARES-PER-TURN# hotel-ordering))]
strategy.rkt:         (to-buy b my-cash available-shares (choose-shares# SHARES-PER-TURN#) hotel-ordering))
strategy.rkt:(define-syntax-rule 
strategy.rkt:  (let ([x (for/list . b)]) (if (empty? x) #f (randomly-pick x))))
strategy.rkt:(define-syntax-rule 
strategy.rkt:(define ordered-s     (strategy for/or     first         alphabetically-first))
strategy.rkt:(define random-s      (strategy for/random randomly-pick randomly-pick        random+1 values))
strategy.rkt:(define largest-alpha (strategy for/ror    first         alphabetically-first))
strategy.rkt:(define smallest-anti (strategy for/or     first         alphabetically-first values   reverse))
strategy.rkt:;; ---------------------------------------------------------------------------------------------------
strategy.rkt:  ;; Strategy Board Cash [Listof Tile] Shares [Listof Hotel] [Maybe Tile] [Maybe Hotel] Shares -> Any 
strategy.rkt:  (define (test S b cash tiles available-sh available-htls e-placement e-hotel e-shares)
strategy.rkt:    (call-with-values 
strategy.rkt:       (S (new sturn% [board b][tiles tiles][cash cash][shares available-sh][hotels available-htls])))
strategy.rkt:     (lambda (placement hotel shares-to-buy)
strategy.rkt:       (define kind (if placement (what-kind-of-spot b placement) IMPOSSIBLE))
strategy.rkt:       (check-true (if (and hotel placement) (cons? (member kind (list FOUNDING MERGING))) #t))
strategy.rkt:       (check-equal? hotel e-hotel)
strategy.rkt:       (check-equal? placement e-placement)
strategy.rkt:       (check-equal? shares-to-buy e-shares))))
strategy.rkt:      (init-field board tiles cash shares hotels)
strategy.rkt:      (super-new)
strategy.rkt:  ;; -------------------------------------------------------------------------------------------------
strategy.rkt:  (define tower-shares (*create-shares TOWER 3))
strategy.rkt:    (*combine-shares 
strategy.rkt:      (*create-shares FESTIVAL 1) tower-shares)))
strategy.rkt:  (define h0 ALL-HOTELS)
strategy.rkt:  (test ordered-s     b0 CASH0 t0 banker-shares0 h0 A2 #f `(,AMERICAN ,AMERICAN))
strategy.rkt:  (test largest-alpha b0 CASH0 t0 banker-shares0 h0 A7 #f `(,AMERICAN ,AMERICAN))
strategy.rkt:  (test smallest-anti b0 CASH0 t0 banker-shares0 h0 A2 #f `(,TOWER ,TOWER))
strategy.rkt:  (test ordered-s     b0 CASH0 t0 tower-shares h0 A2 #f `(,TOWER ,TOWER))
strategy.rkt:  (test largest-alpha b0 CASH0 t0 tower-shares h0 A7 #f `(,TOWER ,TOWER))
strategy.rkt:  (test smallest-anti b0 CASH0 t0 tower-shares h0 A2 #f `(,TOWER ,TOWER))
strategy.rkt:  (test ordered-s     b0 CASH0 t0 s0 h0 A2 #f `(,FESTIVAL))
strategy.rkt:  (test largest-alpha b0 CASH0 t0 s0 h0 A7 #f `(,FESTIVAL))
strategy.rkt:  (test smallest-anti b0 CASH0 t0 s0 h0 A2 #f `(,TOWER ,TOWER))
strategy.rkt:  (test ordered-s     b0 10 t0 s0 h0 A2 #f '())
strategy.rkt:  (test largest-alpha b0 10 t0 s0 h0 A7 #f '())
strategy.rkt:  (test smallest-anti b0 10 t0 s0 h0 A2 #f '())
strategy.rkt:  ;; -------------------------------------------------------------------------------------------------
strategy.rkt:  (define b1 (*create-board-with-hotels (list A1) '()))
strategy.rkt:  (test ordered-s     b1 CASH0 t0 banker-shares0 h0 A2 AMERICAN `(,AMERICAN ,AMERICAN))
strategy.rkt:  (test largest-alpha b1 CASH0 t0 banker-shares0 h0 A7 #f       `(,AMERICAN ,AMERICAN))
strategy.rkt:  (test smallest-anti b1 CASH0 t0 banker-shares0 h0 A2 AMERICAN `(,TOWER ,TOWER))
strategy.rkt:  ;; -------------------------------------------------------------------------------------------------
strategy.rkt:  (define Sackson-tiles
strategy.rkt:           (build-list 12 (lambda (i) (ctile F (+ i 1))))
strategy.rkt:           (build-list 12 (lambda (i) (ctile G (+ i 1))))
strategy.rkt:           (build-list 12 (lambda (i) (ctile H (+ i 1)))))))
strategy.rkt:  (define b2 (*create-board-with-hotels (list I12) (list Sackson-tiles)))
strategy.rkt:  (define price-of-Sackson (price-per-share SACKSON (length Sackson-tiles)))
strategy.rkt:  (define price-of-Worldwide (price-per-share WORLDWIDE 0))
strategy.rkt:  (define s2 (*combine-shares (list (*create-shares SACKSON 2) (*create-shares WORLDWIDE 10))))
strategy.rkt:  (define h2 (remove SACKSON ALL-HOTELS))
strategy.rkt:  (test ordered-s     b2 CASH0 t0 s2 h2 A2 #f `(,SACKSON ,SACKSON))
strategy.rkt:  (test largest-alpha b2 CASH0 t0 s2 h2 A7 #f `(,SACKSON ,SACKSON))
strategy.rkt:  (test smallest-anti b2 CASH0 t0 s2 h2 A2 #f `(,SACKSON ,SACKSON))
strategy.rkt:  ;; -------------------------------------------------------------------------------------------------
strategy.rkt:  (define Worldwide-tiles (cons WORLDWIDE (build-list 6 (lambda (i) (ctile D (+ i 1))))))
strategy.rkt:  (define b3 (*create-board-with-hotels '() (list Worldwide-tiles Sackson-tiles)))
strategy.rkt:  (test ordered-s     b3 CASH0 t3 s2 h3 #f #f `(,SACKSON ,SACKSON))
strategy.rkt:  (test largest-alpha b3 CASH0 t3 s2 h3 #f #f `(,SACKSON ,SACKSON))
strategy.rkt:  (test smallest-anti b3 CASH0 t3 s2 h3 #f #f `(,WORLDWIDE ,WORLDWIDE))
strategy.rkt:  ;; -------------------------------------------------------------------------------------------------
strategy.rkt:  (define Tower-tiles (cons TOWER (list F1 F2)))
strategy.rkt:  (define b4 (*create-board-with-hotels '() (list Worldwide-tiles Tower-tiles)))
strategy.rkt:  (define h4 (remove* `(,WORLDWIDE ,TOWER) ALL-HOTELS))
strategy.rkt:  (test ordered-s     b4 CASH0 t3 s2 h4 E1 WORLDWIDE `(,WORLDWIDE ,WORLDWIDE))
strategy.rkt:  (test largest-alpha b4 CASH0 t3 s2 h4 E6 #f        `(,WORLDWIDE ,WORLDWIDE))
strategy.rkt:  (test smallest-anti b4 CASH0 t3 s2 h4 E1 WORLDWIDE `(,WORLDWIDE ,WORLDWIDE))
strategy.rkt:  (define American-tiles (cons AMERICAN (list E3 E4)))
strategy.rkt:  (define Continental-tiles (cons CONTINENTAL (list D1 D2)))
strategy.rkt:  (define b5 (*create-board-with-hotels '() (list American-tiles Continental-tiles Tower-tiles)))
strategy.rkt:  (define h5 (remove* `(,AMERICAN ,CONTINENTAL ,TOWER) ALL-HOTELS))
strategy.rkt:  (test ordered-s     b5 CASH0 (list E2) s2 h5 E2 AMERICAN '())
strategy.rkt:  (test largest-alpha b5 CASH0 (list E2) s2 h5 E2 AMERICAN '())
strategy.rkt:  (test smallest-anti b5 CASH0 (list E2) s2 h5 E2 AMERICAN '())
strategy.rkt:  ;; -------------------------------------------------------------------------------------------------
strategy.rkt:  (define b7 (*create-board-with-hotels '() (list American-tiles)))
strategy.rkt:  (define t7 (cons B7 (rest (build-list 6 (lambda (i) (ctile A (+ i 1)))))))
strategy.rkt:  (test ordered-s     b7 CASH0 t7 banker-shares0 ALL-HOTELS A2 #f `(,AMERICAN ,AMERICAN))
strategy.rkt:  (test largest-alpha b7 CASH0 t7 banker-shares0 ALL-HOTELS B7 #f `(,AMERICAN ,AMERICAN))
strategy.rkt:  (test smallest-anti b7 CASH0 t7 banker-shares0 ALL-HOTELS A2 #f `(,TOWER ,TOWER))
strategy.rkt:  (define b8 (*create-board-with-hotels '() (list Continental-tiles)))
strategy.rkt:  (define h8 (remove CONTINENTAL ALL-HOTELS))
strategy.rkt:  (test ordered-s     b8 400 t8 (*create-shares CONTINENTAL 1) h8 D3 #f '())
strategy.rkt:  (test largest-alpha b8 400 t8 (*create-shares CONTINENTAL 1) h8 D3 #f '())
strategy.rkt:  (test smallest-anti b8 400 t8 (*create-shares CONTINENTAL 1) h8 D3 #f '())
strategy.rkt:  (define b9 (*create-board-with-hotels (list A1) '()))
strategy.rkt:  (test ordered-s     b9 300 t9 (*create-shares AMERICAN 1) `(,AMERICAN) A2 AMERICAN '())  
strategy.rkt:  (test largest-alpha b9 300 t9 (*create-shares AMERICAN 1) `(,AMERICAN) A2 AMERICAN '())  
strategy.rkt:  (test smallest-anti b9 300 t9 (*create-shares AMERICAN 1) `(,AMERICAN) A2 AMERICAN '())  
tree-game.rkt:exec racket -tm "$0" ${1+"$@"}
tree-game.rkt:;; ---------------------------------------------------------------------------------------------------
tree-game.rkt:  ;; $ ./tree-game n
tree-game.rkt:;; ---------------------------------------------------------------------------------------------------
tree-game.rkt:(require "admin.rkt" "state.rkt" "player-factory.rkt" "Lib/auxiliaries.rkt")
tree-game.rkt:  (for ((i (in-range (string->number n))))
tree-game.rkt:    (go (inf-loop-player 0))))
tree-game.rkt:  (define p1 (random-players 5))
tree-game.rkt:  (define-values (two-status _score two-run) (run p 99 #:choice randomly-pick))
tree-game.rkt:  (displayln `(,(length two-run) ,two-status)))
tree-game.rkt:(define (run players turns# #:show (show values #;(show)) #:choice (choose-next-tile first))
tree-game.rkt:  (define a (new administrator% (next-tile choose-next-tile)))
tree-game.rkt:;; -> (Nat Board -> Void)
tree-game.rkt:  (parameterize ((current-eventspace (make-eventspace)))
tree-game.rkt:    (define canvas (new editor-canvas% [parent frame][editor paste]))
tree-game.rkt:      (send paste begin-edit-sequence)
tree-game.rkt:      (send paste select-all)
tree-game.rkt:      (send paste insert (state-draw state) 0 0)
tree-game.rkt:      (send paste end-edit-sequence)
tree-game.rkt:  (define-values (status _score0 test) (run (ordered-players 3) 4))
tree-game.rkt:  (check-equal? (length test) 5)
tree-game.rkt:  (define-values (one-status _score1 one-run) (run (ordered-players 6) 99))
tree-game.rkt:  (check-equal? (length one-run) 25) ; 23
tree-game.rkt:  (check-equal? one-status 'score)
tree-game.rkt:  (define-values (two-status _score2 two-run) (run (random-players 6) 99 #:choice randomly-pick))
tree-game.rkt:  (length two-run)
tree-game.rkt:  two-status
tree-game.rkt:  (go (merge-bad-player))
tree-game.rkt:  (go (keep-bad-player))
tree-game.rkt:  (go (end-bad-player))
tree-game.rkt:  (go (receive-bad-player))
tree-game.rkt:  (go (inform-bad-player))
tree-game.rkt:  (go (setup-bad-player))
tree-game.rkt:  (go (inf-loop-player 1)))
tree-intf.rkt:;; ---------------------------------------------------------------------------------------------------
tree-intf.rkt:  (tree? (-> any/c boolean?))
tree-intf.rkt:  (decision-tree?
tree-intf.rkt:   (-> tree? boolean?))
tree-intf.rkt:  (generate-tree
tree-intf.rkt:   (-> state? tree?))
tree-intf.rkt:  (tree-state 
tree-intf.rkt:   (-> tree? state?))
tree-intf.rkt:  (tree-next
tree-intf.rkt:   (-> decision-tree?
tree-intf.rkt:       shares-order/c
tree-intf.rkt:       (->i ([lot (listof tile?)]) (one-of-them (lot) (and/c tile? (lambda (x) (member x lot)))))
tree-intf.rkt:       ;; -- yields -- 
tree-intf.rkt:  (tree-founding
tree-intf.rkt:   (-> tree? natural-number/c policies/c natural-number/c))
tree-intf.rkt:  (tree-merging
tree-intf.rkt:   (-> tree? natural-number/c policies/c natural-number/c)))
tree-intf.rkt:;; ---------------------------------------------------------------------------------------------------
tree-intf.rkt:;; (define query/c (-> tree? natural-number/c policies natural-number/c))
tree-intf.rkt:(define policies/c (listof shares-order/c))
tree.rkt:;; ---------------------------------------------------------------------------------------------------
tree.rkt:;; ---------------------------------------------------------------------------------------------------
tree.rkt:(require "tree-intf.rkt" #;unstable/contract) 
tree.rkt: tree? decision-tree? generate-tree
tree.rkt: tree-state tree-next
tree.rkt: tree-founding tree-merging)
tree.rkt:;; ---------------------------------------------------------------------------------------------------
tree.rkt:(require "typed-wrapper.rkt")
tree.rkt:(define-type Policies (Listof Shares-Order))
tree.rkt:#| ---------------------------------------------------------------------------------------------------
tree.rkt:           +----------------------------------------------------------------------------------+
tree.rkt:     +---------------+  implements     +---------------+                                      |
tree.rkt:     | tree<%>       |--------<--------| atree%        |                                      |
tree.rkt:     +---------------+                 +---------------+                                      |
tree.rkt:     +---------------+                 | state         |                                      |
tree.rkt:     | to-state      |                 +---------------+                                      |
tree.rkt:     | next          |                 | to-state      |                                      |
tree.rkt:     +---------------+                 | traversal   a |                                      |
tree.rkt:                                       | lookup-tile a |                                      |
tree.rkt:                                       +---------------+                                      |
tree.rkt:       +--------------------------------------+---------------+                               |
tree.rkt:     +---------------+                                 +-----------------+                    |
tree.rkt:     +---------------+                                 +-----------------+                    |
tree.rkt:     +---------------+                                 | placed          |*----+              |
tree.rkt:     | traversal     |                                 +-----------------+     |              |
tree.rkt:     | lookup-tile   |                                 | traversal       |     |              |
tree.rkt:     |               |                                 | lookup-tile     |     |              |
tree.rkt:     +---------------+                                 | lookup-purchase |     |              |
tree.rkt:                                                       +-----------------+     |              |
tree.rkt:                                             +--------------------------------------------+   |
tree.rkt:                                             +--------------------------------------------+   |
tree.rkt:                                             +--------------------------------------------+   |
tree.rkt:                                             | purchase: Decisions ShareOrder -> HandOut* |   |
tree.rkt:                                             | to-tree : Decisions ShareOrder -> TREE*    |---+
tree.rkt:                                             | acceptable-policies                        |
tree.rkt:                                             +--------------------------------------------+
tree.rkt:[hand-out 
tree.rkt:        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ ...
tree.rkt:#;(struct hand-out (tile tree))
tree.rkt:(struct: hand-out ([tile : Tile] [tree : (Instance ATree%)]))
tree.rkt:(define-type HandOut hand-out)
tree.rkt:;; HandOut = (hand-out t st)
tree.rkt:(define-type Tree<%>
tree.rkt:   [to-state (-> State)]
tree.rkt:   [next (Tile (Option Hotel) (Listof (List Player (Listof (List Hotel Boolean)))) Shares-Order ((Listof Tile) -> Tile) -> (Values (Option Tile) (Instance ATree%)))]
tree.rkt:   [founding (Natural Policies -> Natural)] 
tree.rkt:   [merging (Natural Policies -> Natural)]))
tree.rkt:(define-type ATree%
tree.rkt:         (init-field [state State])
tree.rkt:         [traversal (Natural Policies ((Instance Placed%) -> Natural) -> Natural)]
tree.rkt:         [lookup-tile  (((Listof Tile) -> Tile) (Listof HandOut) -> (Values (Option Tile) (Instance ATree%)))]))
tree.rkt:    (init-field state)
tree.rkt:    (super-new)
tree.rkt:    (define/public (to-state)  
tree.rkt:    (define/public (founding n order-policies)
tree.rkt:      (traversal n order-policies (is-action FOUNDING)))
tree.rkt:    (define/public (merging n order-policies)
tree.rkt:      (traversal n order-policies (is-action MERGING)))
tree.rkt:    ;; Nat [Listof ShareOrder] [Placed -> Nat] -> Nat   
tree.rkt:    ;; private field: ACTION -> Placed -> {0,1}
tree.rkt:    (: is-action (Symbol -> ((Instance Placed%) -> Natural)))
tree.rkt:    (define (is-action tag) (lambda: ([p : (Instance Placed%)])
tree.rkt:      (if (and (placed-hotel p) (eq? (get-field reason p) tag)) 1 0)))
tree.rkt:    ;; use pick-tile to hand out a tile; extract the corresponding subtree 
tree.rkt:    ;; [[Listof Tile] -> Tile] [Listof HandOut] ->* [Maybe Tile] Tree 
tree.rkt:    ;(abstract lookup-tile)
tree.rkt:    (define/public (lookup-tile a b) (error "abstract method"))
tree.rkt:(define-type State%
tree.rkt:         (init-field [state State])))
tree.rkt:    (super-new)
tree.rkt:      (error 'tree-next "finale state can't transition"))
tree.rkt:    (define/override (lookup-tile pick-tile lo-handout)
tree.rkt:(define-type LPlaced%
tree.rkt:         (init-field [state State]
tree.rkt:    (super-new)
tree.rkt:    (init-field lplaced)
tree.rkt:    (define/override (next tile hotel decisions shares-to-buy pick-tile) 
tree.rkt:      (define intermediate (send (lookup-purchase tile hotel) purchase decisions shares-to-buy))
tree.rkt:      (send this lookup-tile pick-tile (assert intermediate list?)))
tree.rkt:    ;; Tile [Maybe Hotel] -> Placed 
tree.rkt:    ;; lookup the one and only Placed from lo-placed that represents the action of placing t (& h)
tree.rkt:    (: lookup-purchase (Tile (Option Hotel) -> (Instance Placed%)))
tree.rkt:    (define/private (lookup-purchase t h)
tree.rkt:      #;(for/first ((p lplaced) #:when (and (equal? (placed-hotel p) h) (equal? (placed-tile p) t)))
tree.rkt:      (let ([lst (filter (lambda: ([p : (Instance Placed%)]) (and (equal? (placed-hotel p) h) (equal? (placed-tile p) t)))
tree.rkt:    (define/override (lookup-tile pick-tile lo-hand-out)
tree.rkt:      (define tile (pick-tile (map hand-out-tile lo-hand-out)))
tree.rkt:      #;(define st (for/first: : (Option State) ((p lo-hand-out) #:when (equal? (hand-out-tile p) tile)) (hand-out-tree p)))
tree.rkt:      (define st (let ([lst (filter (lambda: ([p : HandOut]) (equal? (hand-out-tile p) tile)) lo-hand-out)])
tree.rkt:                        (hand-out-tree (first lst)))))
tree.rkt:            (define d* (map (lambda: ([p : Player]) (list p '())) (state-players (get-field state/tile branch))))
tree.rkt:            (define a (send branch acceptable-policies policies))
tree.rkt:                      (for/sum: : Natural ((st (send branch to-trees d* (first a))))
tree.rkt:                        (send st traversal (- n 1) policies p?))))))))))
tree.rkt:(define-type Decisions (Listof (List Player (Listof (List Hotel Boolean)))))
tree.rkt:(define-type Placed%
tree.rkt:   (init-field [state State]
tree.rkt:   [purchase (Decisions Shares-Order -> (U (Listof HandOut) (Instance State%)))]
tree.rkt:   [to-trees (Decisions Shares-Order -> (Listof (Instance ATree%)))]
tree.rkt:   [acceptable-policies ((Listof Shares-Order) -> (Listof Shares-Order))]))
tree.rkt:    (init-field state tile hotel state/tile reason)
tree.rkt:    (super-new)
tree.rkt:    ;; Decisions ShareOrder -> state% or [Listof HandOut]
tree.rkt:    (define/public (purchase decisions share-order)
tree.rkt:      ;; ---------------------------------------------------------------------------------------------
tree.rkt:        (define players (state-players state/tile))
tree.rkt:          (pretty-print players)
tree.rkt:          (pretty-print ((inst map Player (List Player (Listof (List Hotel Boolean)))) first decisions))
tree.rkt:      ;; ---------------------------------------------------------------------------------------------
tree.rkt:            (state-return-shares state/tile decisions (state-board state))
tree.rkt:      (define state/bought (state-buy-shares state/decisions share-order))
tree.rkt:      (define available-tiles (state-tiles state/bought))
tree.rkt:      (if (empty? available-tiles) 
tree.rkt:          (for/list: : (Listof HandOut) ((tile available-tiles))
tree.rkt:            (hand-out tile (generate-tree (state-next-turn (state-move-tile state/bought tile)))))))
tree.rkt:    ;; Decisions ShareOrder -> [Listof Tree]
tree.rkt:    (define/public (to-trees decisions share-order)
tree.rkt:      (define state-or-hand-out (purchase decisions share-order))
tree.rkt:        [(cons? state-or-hand-out) ((inst map (Instance ATree%) HandOut) hand-out-tree (assert state-or-hand-out list?))]
tree.rkt:        [else (assert state-or-hand-out list?)]))
tree.rkt:    ;; [Listof ShareOrder] -> [Listof ShareOrder]
tree.rkt:    (define/public (acceptable-policies policies)
tree.rkt:      (define budget (player-money (state-current-player state)))
tree.rkt:      (define board  (state-board state))
tree.rkt:      (define shares (state-shares state))
tree.rkt:                 #:when (and (shares-available? shares p) (affordable? board p budget)))
tree.rkt:(: placed-tile ((Instance Placed%) -> Tile))
tree.rkt:(: placed-hotel ((Instance Placed%) -> Hotel))
tree.rkt:(define (placed-tile p) (get-field tile p))
tree.rkt:(define (placed-hotel p) (get-field hotel p))
tree.rkt:;; ---------------------------------------------------------------------------------------------------
tree.rkt:(: generate-tree (State -> (Instance ATree%)))
tree.rkt:(define (generate-tree state)
tree.rkt:    [(state-final? state) (new state% [state state])]
tree.rkt:    [else (define board (state-board state))
tree.rkt:          (define available-hotels (state-hotels state))
tree.rkt:            (for/fold: : (Listof (Instance Placed%)) ((lo-placed : (Listof (Instance Placed%)) '())) ((t (player-tiles (state-current-player state))))
tree.rkt:              (define kind (what-kind-of-spot board t))
tree.rkt:                  [(and (eq? FOUNDING kind) (cons? available-hotels)) available-hotels]
tree.rkt:                   (define-values (acquirers _) (merging-which board t))
tree.rkt:              (define new-placements
tree.rkt:                    (if h (state-place-tile state t h) (state-place-tile state t)))
tree.rkt:              (append new-placements lo-placed)))
tree.rkt:  (define (make-decisions players)
tree.rkt:  (define p1 (*create-player "a" 1000 player-shares0 Alist))
tree.rkt:  (define p2 (*create-player "b" 1000 player-shares0 (list B1 B2 B3 B4 B5 B6)))
tree.rkt:  (define p3 (*create-player "c" 1000 player-shares0 (list C1 C2 C3 C4 C5 C6)))
tree.rkt:  (define p4 (*create-player "d" 1000 player-shares0 (list D1 D2 D3 D4 D5 D6)))
tree.rkt:  (define p5 (*create-player "e" 1000 player-shares0 (list E1 E2 E3 E4 E5 E6)))
tree.rkt:  (define p6 (*create-player "f" 1000 player-shares0 (list F1 F2 F3 F4 F5 F6)))
tree.rkt:    (define safe-hotel `((,TOWER ,@(build-list SAFE# (lambda (i) (ctile H  (+ i 1)))))))
tree.rkt:    (define safe-board (*create-board-with-hotels '() safe-hotel))
tree.rkt:    (define safe-state (*create-state safe-board (list p1 p2 p3)))
tree.rkt:    (check-equal? (tree-state (generate-tree safe-state)) safe-state))
tree.rkt:    (define player-can-place-c5 (*create-player "a" 1000 player-shares0 (list C5)))
tree.rkt:    (define board-found-at-c5 board-a1-b2-c6)
tree.rkt:    (define state-found-at-c5 (*create-state board-found-at-c5 (list player-can-place-c5)))
tree.rkt:    (define tree-foundings-at-c5 (generate-tree state-found-at-c5))
tree.rkt:    (check-equal? (apply set (map placed-hotel (get-field lplaced tree-foundings-at-c5)))
tree.rkt:                  (apply set ALL-HOTELS)
tree.rkt:    (define shares-for-am-tw-ww 
tree.rkt:      (*combine-shares
tree.rkt:       (list (*create-shares AMERICAN 3) (*create-shares TOWER 3) (*create-shares WORLDWIDE 3))))
tree.rkt:    (define player-can-place-d3 (*create-player "a" 1000 shares-for-am-tw-ww (list D3)))
tree.rkt:    (define state-merge-at-d3 (*create-state board-3way-merger-at-d3 (list player-can-place-d3)))
tree.rkt:    (define tree-merging-at-d3 (generate-tree state-merge-at-d3))
tree.rkt:    (define branches (get-field lplaced tree-merging-at-d3))
tree.rkt:    (check-equal? (apply set (map placed-hotel branches)) (set TOWER AMERICAN) 
tree.rkt:    (define (check-money placed)
tree.rkt:      (define acquired (other (placed-hotel placed)))
tree.rkt:      (define trees  (send placed to-trees `((,player-can-place-d3 ,decisions)) '()))
tree.rkt:      (define tree1  (randomly-pick trees)) ;; <-- replace with fixed branch if buggy
tree.rkt:      (define state1 (get-field state tree1))
tree.rkt:      (check-equal? (player-money (first (state-players state1)))
tree.rkt:                    (+ (player-money player-can-place-d3)
tree.rkt:                         (+ (bonus 'majority h (size-of-hotel board-3way-merger-at-d3 h))
tree.rkt:                            (* (shares-available shares-for-am-tw-ww h)
tree.rkt:                               (price-per-share h (size-of-hotel board-3way-merger-at-d3 h))))))))
tree.rkt:    (check-money (first branches))
tree.rkt:    (check-money (second branches)))
tree.rkt:    (define p1-p6 (list p1 p2 p3 p4 p5 p6))
tree.rkt:    (define all-remaining-tiles (remove* (apply append (map player-tiles p1-p6)) ALL-TILES))
tree.rkt:    (define board-with-remaining-tiles (*create-board-with-hotels all-remaining-tiles '()))
tree.rkt:    (define state-without-admin-tiles (*create-state board-with-remaining-tiles p1-p6))
tree.rkt:    (define tree-without-admin-tiles (generate-tree state-without-admin-tiles))
tree.rkt:    (check-equal? (apply set (map placed-tile (get-field lplaced tree-without-admin-tiles)))
tree.rkt:    (for ((p (get-field lplaced tree-without-admin-tiles)))
tree.rkt:      (define s (send p to-trees (make-decisions p1-p6) '()))
tree.rkt:      (check-true (is-a? s state%) "the resulting subtree is awlays a state"))))
tree.rkt:;; ---------------------------------------------------------------------------------------------------
tree.rkt:(: tree-next ((Instance LPlaced%) Tile (Option Hotel) (Listof (List Player (Listof (List Hotel Boolean)))) Shares-Order ((Listof Tile) -> Tile) -> (Values (Option Tile) (U (Instance State%) (Instance LPlaced%)))))
tree.rkt:(define (tree-next current-tree tile hotel decisions shares-to-buy pick-tile)
tree.rkt:  (send current-tree next tile hotel decisions shares-to-buy pick-tile))
tree.rkt:(: tree? (Any -> Boolean))
tree.rkt:  (or (is-a? x state%) (is-a? x lplaced%)))
tree.rkt:(: decision-tree? (Any -> Boolean))
tree.rkt:(define (decision-tree? x)
tree.rkt:  (and (is-a? x lplaced%) (cons? (get-field lplaced (cast x (Instance LPlaced%))))))
tree.rkt:(: tree-state ((U (Instance State%) (Instance LPlaced%)) -> State))
tree.rkt:(define (tree-state t)
tree.rkt:  (send t to-state))
tree.rkt:  (define (smallest-tile lot)
tree.rkt:    (define safe-hotel `((,TOWER ,@(build-list SAFE# (lambda (i) (ctile H  (+ i 1)))))))
tree.rkt:    (define safe-board (*create-board-with-hotels '() safe-hotel))
tree.rkt:    (define safe-state (*create-state safe-board (list p1 p2 p3)))
tree.rkt:    (check-exn exn:fail? 
tree.rkt:               (lambda () (tree-next (generate-tree safe-state) I12 #f '() '() randomly-pick))))
tree.rkt:    (define player-can-place-c5 (*create-player "a" 1000 player-shares0 (list C5)))
tree.rkt:    (define board-with-six-hotels-found-at-c5
tree.rkt:      (*create-board-with-hotels
tree.rkt:    (define p (list player-can-place-c5))
tree.rkt:    (define t (generate-tree (*create-state board-with-six-hotels-found-at-c5 p)))
tree.rkt:    (define-values (_ lo-decisions) (tree-next t C5 WORLDWIDE (make-decisions p) '() smallest-tile))
tree.rkt:    (check-equal? (length (get-field lplaced lo-decisions)) 1))
tree.rkt:    (define player-can-place-3 (list (*create-player "a" 1000 player-shares0 (list A2 B1 C5))))
tree.rkt:    (define board-found-at-3 board-a1-b2-c6)
tree.rkt:    (define state-found-at-3 (*create-state board-found-at-3 player-can-place-3))
tree.rkt:    (define tree-foundings-at-3 (generate-tree state-found-at-3))
tree.rkt:    (define-values (_ lo-placed1) 
tree.rkt:      (tree-next tree-foundings-at-3 C5 AMERICAN (make-decisions player-can-place-3) '() smallest-tile))
tree.rkt:    (define lo-placed (get-field lplaced lo-placed1))
tree.rkt:    ;; can now found six additional hotels, twice, plus place a singleton with smallest-tile obtained
tree.rkt:    (check-equal? (length lo-placed) (+ (* 2 (length (state-hotels (tree-state lo-placed1)))) 1)))
tree.rkt:    (define shares-for-am-tw-ww 
tree.rkt:      (list (*create-shares AMERICAN 3) (*create-shares TOWER 3) (*create-shares WORLDWIDE 3)))
tree.rkt:    (define player-can-place-d3  
tree.rkt:      (list (*create-player "a" 1000 (*combine-shares shares-for-am-tw-ww) (list D3))))
tree.rkt:    (define state-merge-at-d3 
tree.rkt:      (*create-state board-3way-merger-at-d3 player-can-place-d3))
tree.rkt:    (define tree-merging-at-d3 (generate-tree state-merge-at-d3))
tree.rkt:    (define d* (make-decisions player-can-place-d3))
tree.rkt:    (define-values (_1 lop1) (tree-next tree-merging-at-d3 D3 TOWER d* '() smallest-tile))
tree.rkt:    (check-equal? (length (get-field lplaced lop1)) 1)
tree.rkt:    (define-values (_2 lop2) (tree-next tree-merging-at-d3 D3 AMERICAN d* '() smallest-tile))
tree.rkt:    (check-equal? (length (get-field lplaced lop2)) 1)))
tree.rkt:;; ---------------------------------------------------------------------------------------------------
tree.rkt:(: tree-founding ((U (Instance State%) (Instance LPlaced%)) Natural Policies -> Natural))
tree.rkt:(define (tree-founding current-tree n order-policies)
tree.rkt:  (send current-tree founding n order-policies))
tree.rkt:(: tree-merging ((U (Instance State%) (Instance LPlaced%)) Natural Policies -> Natural))
tree.rkt:(define (tree-merging current-tree n order-policies)
tree.rkt:  (send current-tree merging n order-policies))
tree.rkt:    (define safe-hotel `((,TOWER ,@(build-list SAFE# (lambda (i) (ctile H  (+ i 1)))))))
tree.rkt:    (define safe-board (*create-board-with-hotels '() safe-hotel))
tree.rkt:    (define safe-state (*create-state safe-board (list p1 p2 p3)))
tree.rkt:    (check-equal? (tree-founding (generate-tree safe-state) 1 policy) 0))
tree.rkt:    (define player-can-place-3 (*create-player "a" 1000 player-shares0 (list A2 B1 C5)))
tree.rkt:    (define board-found-at-3 board-a1-b2-c6)
tree.rkt:    (define state-found-at-3 (*create-state board-found-at-3 (list player-can-place-3)))
tree.rkt:    (define tree-foundings-at-3 (generate-tree state-found-at-3))
tree.rkt:    (check-equal? (tree-founding tree-foundings-at-3 1 policy) 
tree.rkt:                  (* 3 (length (state-hotels state-found-at-3)))))
tree.rkt:    (define pc5 (*create-player "a" 1000 player-shares0 (list C5)))
tree.rkt:      (*create-board-with-hotels
tree.rkt:    (define sff (*create-state bff (list pc5)))
tree.rkt:    (define tree (generate-tree sff))
tree.rkt:    (check-equal? (tree-founding tree 1 policy) 1)
tree.rkt:    (check-equal? (tree-founding tree 2 policy) 1)
tree.rkt:    (check-equal? (tree-founding tree 3 policy) 1))
tree.rkt:    (define shares-for-am-tw-ww 
tree.rkt:      (list (*create-shares AMERICAN 3) (*create-shares TOWER 3) (*create-shares WORLDWIDE 3)))
tree.rkt:    (define player-can-place-d3 
tree.rkt:      (*create-player "a" 1000 (*combine-shares shares-for-am-tw-ww) (list D3)))
tree.rkt:    (define state-merge-at-d3 
tree.rkt:      (*create-state board-3way-merger-at-d3 (list player-can-place-d3)))
tree.rkt:    (define mmm (generate-tree state-merge-at-d3))
tree.rkt:    (check-equal? (tree-merging mmm 1 policy) 2)
tree.rkt:    (check-equal? (tree-merging mmm 2 policy) 2)))
xharness.rkt:;; ---------------------------------------------------------------------------------------------------
xharness.rkt:(require (only-in xml xexpr?))
xharness.rkt: (contract-out 
xharness.rkt:  (make-main 
xharness.rkt:   (-> (-> xexpr? xexpr?) (-> any)))
xharness.rkt:  (make-process-request 
xharness.rkt:   (-> (-> xexpr? xexpr?) (-> xexpr? xexpr?))))
xharness.rkt: state-p 
xharness.rkt: player-p
xharness.rkt: hotel-p
xharness.rkt: board-p
xharness.rkt: tile-p
xharness.rkt: share-p)
xharness.rkt:;; ---------------------------------------------------------------------------------------------------
xharness.rkt:;; -> Void 
xharness.rkt:(define (make-main interpret)
xharness.rkt:  (define process (make-process-request interpret))
xharness.rkt:      (define request (read-xml-from))
xharness.rkt:      (unless (eof-object? request)
xharness.rkt:          [else (write-xml-to response) (loop)]))))
xharness.rkt:;; Request -> Response 
xharness.rkt:(define ((make-process-request interpret) request)
xharness.rkt:  (with-handlers ((exn:fail:contract:blame? (lambda (x) `(error ((msg ,(exn-message x)))))))
xharness.rkt:;; Xexpr -> State 
xharness.rkt:(define state-p 
xharness.rkt:  (xml-parser (state () (b board-p) (p player-p) ... #:action (*create-state b p))))
xharness.rkt:;; Xexpr -> Player
xharness.rkt:(define player-p
xharness.rkt:  (xml-parser (player ((name values) (cash string->cash)) (s share-p) ... (t tile-p) ...
xharness.rkt:                      #:action (*create-player name cash (*combine-shares s) t))))
xharness.rkt:;; Xexpr -> Hotel 
xharness.rkt:(define hotel-p
xharness.rkt:  (xml-parser (hotel ((label string->hotel)) #:action label)))
xharness.rkt:;; Xexpr -> [Maybe Board]
xharness.rkt:(define board-p
xharness.rkt:  (xml-parser
xharness.rkt:   (board () (t tile-p) ... (h board-hotel-p) ... #:action (*create-board-with-hotels t h))))
xharness.rkt:;; Xexpr -> [Maybe (cons Hotel (cons Tile (cons Tile [Listof Tile])))]
xharness.rkt:(define board-hotel-p 
xharness.rkt:  (xml-parser
xharness.rkt:   (hotel ((name string->hotel)) (t1 tile-p) (t2 tile-p) (t tile-p) ... 
xharness.rkt:;; Xexpr -> Tile 
xharness.rkt:(define tile-p 
xharness.rkt:  (xml-parser (tile ((column string->column) (row string->row)) #:action (tile column row))))
xharness.rkt:;; Xexpr -> Hotel
xharness.rkt:(define share-p
xharness.rkt:  (xml-parser (share ((name string->hotel) (count string->count)) 
xharness.rkt:                     #:action (*create-shares name count))))
xrun.rkt:;; ---------------------------------------------------------------------------------------------------
xrun.rkt:;; via some xml-diff checker 
xrun.rkt:(provide main test-directory xml-diff xclient)
xrun.rkt:;; it relies on a script in xdiff-xml that compares XML outputs in the
xrun.rkt:(define test-directory (make-parameter #f))
xrun.rkt:(define xml-diff       (make-parameter #f))
xrun.rkt:(define xclient        (make-parameter #f))
xrun.rkt:;; ---------------------------------------------------------------------------------------------------
xrun.rkt:    (parameterize ((current-directory (test-directory)))
xrun.rkt:      (for/list ((f (directory-list)) #:when (regexp-match #px"in(\\d).xml$" (path->string f)))
xrun.rkt:	(second (regexp-match #px"in(\\d).xml$" (path->string f))))))
xrun.rkt:;; String [Nat] -> Boolean 
xrun.rkt:  (displayln "-----------------------------------------------------------------------------")
xrun.rkt:  (define client (format (xclient) (test-directory) n))
xrun.rkt:  (define xdiff  (format (xml-diff) (test-directory) n))
